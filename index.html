<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Chess Coach Pro (Fixed)</title>
    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { background-color: #f0f2f5; touch-action: manipulation; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        .board-container {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 12px;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            position: relative; 
        }

        #board { 
            flex: 1; 
            min-width: 0; 
            width: 100%; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); 
            z-index: 1;
        }

        #arrowOverlay {
            position: absolute;
            top: 0;
            left: 68px;
            width: calc(100% - 68px);
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .highlight-last { background-color: rgba(255, 255, 0, 0.4) !important; }

        /* Heatmap */
        .square-control-w-1 { box-shadow: inset 0 0 0 1000px rgba(74, 222, 128, 0.2); }
        .square-control-w-2 { box-shadow: inset 0 0 0 1000px rgba(34, 197, 94, 0.4); }
        .square-control-w-3 { box-shadow: inset 0 0 0 1000px rgba(21, 128, 61, 0.6); }
        .square-control-b-1 { box-shadow: inset 0 0 0 1000px rgba(248, 113, 113, 0.2); }
        .square-control-b-2 { box-shadow: inset 0 0 0 1000px rgba(239, 68, 68, 0.4); }
        .square-control-b-3 { box-shadow: inset 0 0 0 1000px rgba(185, 28, 28, 0.6); }

        /* Stability Bar */
        .stability-bar-container {
            flex: 0 0 14px;
            width: 14px;
            background-color: #374151;
            border-radius: 4px;
            overflow: visible; /* Modified to allow indicator to sit on top */
            margin-left: 4px;
            display: flex;
            flex-direction: column-reverse;
            gap: 1px;
            padding: 1px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            z-index: 5;
            position: relative;
        }
        .stability-segment {
            flex: 1;
            width: 100%;
            border-radius: 1px;
            transition: background-color 0.3s;
        }
        .turn-indicator-dot {
            position: absolute;
            top: -8px; /* Lifted up slightly */
            left: 50%;
            transform: translateX(-50%);
            width: 10px; /* Slightly larger */
            height: 10px;
            border-radius: 50%;
            /* Border and Bg set by JS */
            z-index: 20;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
            /* Removed transition for static feel */
        }
        .stab-green { background-color: #22c55e; }
        .stab-yellow { background-color: #eab308; }
        .stab-red { background-color: #ef4444; }
        .stab-empty { background-color: #262626; } /* Neutral Dark Gray */

        /* Eval Bar */
        .eval-bar-container {
            flex: 0 0 26px;
            width: 26px;
            background-color: #374151;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column-reverse;
            z-index: 5;
        }
        .eval-bar-fill {
            width: 100%;
            background-color: #ffffff;
            height: 50%;
            transition: height 0.5s ease-out;
            border-top: 1px solid #9ca3af;
        }
        .eval-score-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            color: #999;
            z-index: 10;
            top: 4px;
            pointer-events: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            white-space: nowrap;
        }
        .eval-score-text.bottom { top: auto; bottom: 4px; color: #ccc; }
        
        .piece-417db { background-size: 100%; }

        /* Coach Box */
        .coach-box {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-left: 5px solid #cbd5e1;
            transition: all 0.3s ease;
            position: relative;
            min-height: 160px;
        }
        .coach-box.pv-active { border-left-color: #6366f1; background: #eef2ff; }
        .coach-box.practice-active { border-left-color: #f59e0b; background: #fffbeb; }

        .coach-box.best { border-left-color: #22c55e; background: #f0fdf4; }
        .coach-box.excellent { border-left-color: #16a34a; background: #f0fdf4; }
        .coach-box.good { border-left-color: #84cc16; }
        .coach-box.inaccuracy { border-left-color: #facc15; background: #fefce8; } 
        .coach-box.mistake { border-left-color: #f97316; background: #fff7ed; } 
        .coach-box.miss { border-left-color: #f43f5e; background: #fff1f2; } 
        .coach-box.blunder { border-left-color: #dc2626; background: #fef2f2; } 
        .coach-box.book { border-left-color: #a855f7; }

        .classification-badge {
            font-size: 0.7rem; text-transform: uppercase; font-weight: 800; letter-spacing: 0.05em;
            padding: 2px 6px; border-radius: 4px; color: white; display: inline-block; margin-bottom: 4px;
        }
        .bg-best { background-color: #22c55e; }
        .bg-excellent { background-color: #16a34a; }
        .bg-good { background-color: #84cc16; }
        .bg-inaccuracy { background-color: #eab308; color: #fff; }
        .bg-mistake { background-color: #f97316; }
        .bg-miss { background-color: #f43f5e; }
        .bg-blunder { background-color: #dc2626; }
        .bg-book { background-color: #a855f7; }
        .bg-neutral { background-color: #94a3b8; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .pv-controls-container, .practice-controls-container { display: none; flex-direction: column; height: 100%; justify-content: space-between; }
        .pv-active .pv-controls-container { display: flex; }
        .pv-active .normal-feedback { display: none; }
        .practice-active .practice-controls-container { display: flex; }
        .practice-active .normal-feedback { display: none; }
        
        .board-pv-highlight { box-shadow: 0 0 0 4px #6366f1 !important; }
        .board-practice-mode { box-shadow: 0 0 0 4px #f59e0b !important; }

        .practice-success { animation: pulseGreen 1s; }
        .practice-fail { animation: shake 0.5s; }

        @keyframes pulseGreen { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body class="pb-12">

    <nav class="bg-indigo-700 text-white p-3 shadow-md sticky top-0 z-50">
        <div class="max-w-2xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-3">
                <button onclick="toggleSidebar()" class="text-white hover:text-indigo-200 text-xl" title="Game Library">
                    <i class="fa-solid fa-bars"></i>
                </button>
                <h1 class="font-bold text-lg"><i class="fa-solid fa-chess"></i> Chess Coach Pro</h1>
            </div>
            <div class="flex gap-2">
                <button onclick="toggleHeatmap()" class="text-white hover:text-indigo-200" title="Toggle Threat Map">
                    <i class="fa-solid fa-eye"></i>
                </button>
                <button onclick="flipBoard()" class="text-white hover:text-indigo-200" title="Flip Board">
                    <i class="fa-solid fa-retweet"></i>
                </button>
                <button onclick="openSettings()" class="text-white hover:text-indigo-200">
                    <i class="fa-solid fa-gear"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Sidebar -->
    <div id="sidebarOverlay" onclick="toggleSidebar()" class="fixed inset-0 bg-black/50 z-[60] hidden transition-opacity"></div>
    <div id="librarySidebar" class="fixed top-0 left-0 h-full w-72 bg-white shadow-2xl transform -translate-x-full transition-transform duration-300 z-[70] flex flex-col">
        <div class="bg-indigo-700 text-white p-4 flex justify-between items-center shadow-md">
            <h2 class="font-bold text-lg flex items-center gap-2"><i class="fa-solid fa-book-open"></i> Game Library</h2>
            <button onclick="toggleSidebar()" class="text-indigo-200 hover:text-white transition-colors"><i class="fa-solid fa-times text-xl"></i></button>
        </div>
        <div id="gameListContainer" class="flex-1 overflow-y-auto p-2 space-y-2 bg-gray-100">
            <!-- Games injected here -->
            <div class="text-center text-gray-400 mt-10 text-sm italic">No games saved yet.</div>
        </div>
    </div>

    <div class="max-w-2xl mx-auto p-4 flex flex-col gap-4">

        <!-- Match Header (Profile Cards) -->
        <div id="matchHeader" class="hidden flex flex-col gap-2 mb-2">
            <div class="flex justify-between items-stretch gap-2">
                <!-- White Card -->
                <div class="flex-1 bg-white rounded-lg shadow-sm p-3 border-l-4 border-gray-400 flex flex-col items-center justify-center relative overflow-hidden">
                    <div class="absolute top-0 left-0 w-full h-1 bg-gray-200"></div>
                    <i id="whiteArchIcon" class="fa-solid fa-chess-pawn text-2xl text-gray-300 mb-1"></i>
                    <div id="whiteAccuracy" class="text-2xl font-black text-gray-800">--%</div>
                    <div id="whiteArchetype" class="text-[10px] uppercase font-bold text-gray-500 tracking-wider">Waiting...</div>
                    <div class="absolute bottom-1 right-2 text-[10px] font-bold text-gray-300">WHITE</div>
                </div>

                <!-- Black Card -->
                <div class="flex-1 bg-white rounded-lg shadow-sm p-3 border-r-4 border-black flex flex-col items-center justify-center relative overflow-hidden">
                    <div class="absolute top-0 left-0 w-full h-1 bg-gray-800"></div>
                    <i id="blackArchIcon" class="fa-solid fa-chess-pawn text-2xl text-gray-300 mb-1"></i>
                    <div id="blackAccuracy" class="text-2xl font-black text-gray-800">--%</div>
                    <div id="blackArchetype" class="text-[10px] uppercase font-bold text-gray-500 tracking-wider">Waiting...</div>
                    <div class="absolute bottom-1 left-2 text-[10px] font-bold text-gray-400">BLACK</div>
                </div>
            </div>

            <!-- Complexity Meter -->
            <div class="bg-white rounded-full p-1 shadow-sm flex items-center gap-2 border border-gray-100">
                <span class="text-[10px] font-bold text-green-600 pl-2">CALM</span>
                <div class="flex-1 h-3 bg-gray-200 rounded-full overflow-hidden relative">
                    <!-- Background Gradient: Green -> Indigo -> Purple -> Red -->
                    <div class="absolute inset-0 bg-gradient-to-r from-green-400 via-indigo-400 via-purple-500 to-red-500 opacity-20"></div>
                    <div id="complexityFill" class="h-full bg-gradient-to-r from-green-500 via-indigo-500 via-purple-600 to-red-600 shadow-[0_0_10px_rgba(99,102,241,0.3)] transition-all duration-1000" style="width: 0%"></div>
                </div>
                <span class="text-[10px] font-bold text-red-500 pr-2">CHAOS</span>
                <div id="complexityScore" class="bg-gray-800 text-white text-[10px] font-bold px-2 rounded-full">0.0</div>
            </div>
        </div>

        <div class="flex justify-between items-center bg-white p-3 rounded-lg shadow-sm">
            <div class="flex items-center gap-3">
                <div id="turnIndicator" class="w-3 h-3 rounded-full bg-white border-2 border-black"></div>
                <div class="flex flex-col">
                    <span id="gameStatus" class="text-xs font-semibold text-gray-700">Load a game to start</span>
                    <span id="openingName" class="text-[10px] text-gray-500 font-mono truncate max-w-[150px]"></span>
                </div>
            </div>
            <div class="flex flex-col items-end">
                <div id="evalText" class="font-mono text-sm bg-gray-800 text-yellow-400 px-2 py-1 rounded">0.00</div>
                <div id="wdlText" class="text-[10px] text-gray-400 font-bold mt-1 hidden">Win: 50%</div>
            </div>
        </div>

        <div class="relative board-container">
            <div class="eval-bar-container">
                <div class="eval-score-text" id="evalBarTextTop"></div>
                <div id="visualEvalBar" class="eval-bar-fill" style="height: 50%;"></div>
                <div class="eval-score-text bottom" id="evalBarTextBottom"></div>
            </div>
            <div id="stabilityBar" class="stability-bar-container">
                <div id="turnIndicatorIcon" class="turn-indicator-dot bg-white"></div>
            </div>

            <div id="board" class="relative transition-shadow duration-300"></div>
            
            <svg id="arrowOverlay"></svg>

            <div id="analysisOverlay" class="absolute inset-0 bg-white/95 z-20 hidden flex flex-col items-center justify-center rounded">
                <button onclick="cancelAnalysis()" class="absolute top-2 right-2 text-gray-400 hover:text-red-500 p-2">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
                <div id="statusTitle" class="text-indigo-600 font-bold mb-4 text-lg animate-pulse">Analyzing with Stockfish...</div>
                <div class="w-64 h-3 bg-gray-200 rounded-full overflow-hidden mb-2">
                    <div id="progressBar" class="h-full bg-indigo-500 transition-all duration-300" style="width: 0%"></div>
                </div>
                <div id="progressText" class="text-xs text-gray-500 font-mono">Initializing...</div>
                <div id="geminiStatus" class="text-xs text-purple-600 mt-2 font-bold hidden">Coach is generating insights...</div>
            </div>
            
            <div id="pvModeBadge" class="absolute top-2 right-2 bg-indigo-600 text-white text-xs px-3 py-1 rounded-full shadow-lg hidden pointer-events-none z-10 font-bold animate-bounce">
                Best Line Explorer
            </div>
            <div id="practiceModeBadge" class="absolute top-2 right-2 bg-amber-500 text-white text-xs px-3 py-1 rounded-full shadow-lg hidden pointer-events-none z-10 font-bold animate-pulse">
                Practice Mode
            </div>
        </div>

        <div class="flex flex-col gap-2">
            <div class="grid grid-cols-5 gap-2" id="mainNavButtons">
                <button onclick="goToStart()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angles-left"></i></button>
                <button onclick="prevMove()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angle-left"></i></button>
                
                <div class="relative group">
                    <button onclick="startAnalysis()" id="analyzeBtn" class="w-full h-full bg-indigo-600 text-white font-bold p-2 rounded shadow hover:bg-indigo-700 flex justify-center items-center gap-2">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> Review
                    </button>
                </div>

                <button onclick="nextMove()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angle-right"></i></button>
                <button onclick="goToEnd()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angles-right"></i></button>
            </div>
            
            <div class="flex justify-end items-center gap-2 text-xs text-gray-600" id="analysisOptions">
                <button onclick="copyAnalysisToClipboard()" class="bg-white border border-gray-300 px-2 py-1 rounded shadow-sm hover:bg-gray-50 text-indigo-700 font-semibold mr-auto">
                    <i class="fa-solid fa-copy"></i> Copy Analysis
                </button>
                <span class="font-bold">Coach Focus:</span>
                <select id="analysisFocus" class="border rounded p-1 bg-white">
                    <option value="both">Both Sides</option>
                    <option value="w">White (My Moves)</option>
                    <option value="b">Black (My Moves)</option>
                </select>
            </div>
        </div>

        <div id="coachBox" class="coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center">
            
            <div class="normal-feedback">
                <div id="feedbackPlaceholder" class="text-center text-gray-400 text-sm">
                    <i class="fa-solid fa-comment-dots text-2xl mb-2"></i><br>
                    Press "Review" to get AI coaching.
                </div>
                
                <div id="feedbackContent" class="hidden">
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <span id="moveClassBadge" class="classification-badge bg-neutral">Neutral</span>
                            <span id="tacticsBadge" class="hidden text-[10px] bg-red-100 text-red-600 px-1 rounded font-bold border border-red-200">TACTIC</span>
                        </div>
                        <span id="moveNumber" class="text-xs text-gray-400 font-mono">1. e4</span>
                    </div>
                    <div id="coachText" class="text-sm text-gray-800 leading-relaxed font-medium"></div>
                    
                    <div id="bestMoveSuggestion" class="hidden mt-3 pt-3 border-t border-gray-200/50 flex flex-col gap-2">
                        <div class="text-xs text-gray-500">
                             Best was: <b id="bestMoveText"></b>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                             <button onclick="startPvReview()" class="bg-indigo-50 text-indigo-700 px-3 py-2 rounded text-xs font-bold hover:bg-indigo-100 transition-colors flex items-center justify-center gap-2 border border-indigo-200">
                                <i class="fa-solid fa-chess-board"></i> View Line
                            </button>
                            <button onclick="startPracticeMode()" class="bg-amber-50 text-amber-700 px-3 py-2 rounded text-xs font-bold hover:bg-amber-100 transition-colors flex items-center justify-center gap-2 border border-amber-200">
                                <i class="fa-solid fa-rotate-left"></i> Retry Move
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pv-controls-container">
                <div class="flex justify-between items-center mb-2 border-b border-indigo-200 pb-2">
                    <span class="text-xs font-bold text-indigo-700 uppercase tracking-wider">Engine Line</span>
                    <button onclick="stopInteractiveMode()" class="text-xs text-gray-400 hover:text-red-500 font-bold px-2">
                        <i class="fa-solid fa-times"></i> EXIT
                    </button>
                </div>
                <div id="pvCommentText" class="text-sm text-gray-800 font-medium mb-3 min-h-[60px]">Loading...</div>
                <div class="flex items-center justify-between bg-white rounded-lg border border-gray-200 p-1">
                    <button onclick="prevPvMove()" class="p-2 text-gray-600 hover:text-indigo-600 hover:bg-gray-50 rounded w-10"><i class="fa-solid fa-chevron-left"></i></button>
                    <div class="text-xs font-mono font-bold text-gray-700" id="pvMoveIndicator">Start</div>
                    <button onclick="nextPvMove()" class="p-2 text-gray-600 hover:text-indigo-600 hover:bg-gray-50 rounded w-10"><i class="fa-solid fa-chevron-right"></i></button>
                </div>
            </div>

            <div class="practice-controls-container">
                <div class="flex justify-between items-center mb-2 border-b border-amber-200 pb-2">
                    <span class="text-xs font-bold text-amber-700 uppercase tracking-wider">Find the Move</span>
                    <button onclick="stopInteractiveMode()" class="text-xs text-gray-400 hover:text-red-500 font-bold px-2">
                        <i class="fa-solid fa-times"></i> GAVE UP
                    </button>
                </div>
                <div id="practiceFeedbackText" class="text-sm text-gray-800 font-medium mb-3 min-h-[40px] flex items-center justify-center text-center">
                    Drag the pieces to find the best move.
                </div>
            </div>

        </div>

        <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden mt-4">
            <div class="bg-gray-50 px-4 py-2 border-b text-xs font-bold text-gray-500 uppercase">Ask the Coach</div>
            <div id="chatHistory" class="p-4 h-40 overflow-y-auto text-sm space-y-2">
                <div class="text-gray-400 italic text-center text-xs mt-10">Ask specific questions about the game here...</div>
            </div>
            <div class="p-2 border-t flex gap-2 bg-gray-50">
                <input type="text" id="chatInput" placeholder="Why was that move bad?" class="flex-1 border rounded px-3 py-1 text-sm focus:outline-none focus:border-indigo-500" onkeypress="handleChatEnter(event)">
                <button onclick="sendChatMessage()" class="bg-indigo-600 text-white px-3 rounded hover:bg-indigo-700"><i class="fa-solid fa-paper-plane"></i></button>
            </div>
        </div>

    </div>

    <div id="settingsModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-sm">
            <h2 class="text-lg font-bold mb-4">Settings</h2>
            <div class="mb-4">
                <label class="block text-xs font-bold text-gray-600 mb-1">Chess.com Username</label>
                <input type="text" id="usernameInput" placeholder="e.g. Hikaru" class="w-full border p-2 rounded text-sm">
            </div>
            <div class="mb-4">
                <label class="block text-xs font-bold text-gray-600 mb-1">Gemini API Key</label>
                <input type="password" id="apiKeyInput" placeholder="Paste key here..." class="w-full border p-2 rounded text-sm">
                <p class="text-xs text-gray-400 mt-1">Key is saved in browser storage.</p>
            </div>
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('settingsModal').classList.add('hidden')" class="px-4 py-2 text-gray-600 text-sm">Close</button>
                <button id="saveKeyBtn" onclick="saveSettings()" class="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">Save Settings</button>
            </div>
        </div>
    </div>

    <div id="pgnModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-md">
            <h2 class="text-lg font-bold mb-2">Load Game</h2>
            <textarea id="pgnInput" class="w-full border p-2 h-40 font-mono text-xs rounded mb-4" placeholder="Paste PGN here..."></textarea>
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('pgnModal').classList.add('hidden')" class="px-4 py-2 text-gray-600 text-sm">Cancel</button>
                <button id="loadPgnBtn" onclick="loadPGN()" class="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">Load Game</button>
            </div>
        </div>
    </div>
    
    <button onclick="document.getElementById('pgnModal').classList.remove('hidden')" class="fixed bottom-6 right-6 bg-indigo-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center hover:bg-indigo-700 z-40 transition-transform hover:scale-110">
        <i class="fa-solid fa-upload text-xl"></i>
    </button>

    <script>
        // --- CONSTANTS ---
        const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        const MODEL_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent';

        // --- STATE ---
        let game = new Chess();
        let board = null;
        let stockfish = null;
        let gameHistory = []; 
        let currentMoveIndex = -1; 
        let analysisData = []; 
        let geminiComments = {}; 
        let gameStats = null;
        let isAnalyzing = false;
        let isHeatmapActive = false;
        let liveAnalysisDebounce = null;
        
        let interactiveState = {
            mode: 'none', 
            pvMoves: [], 
            pvComments: [],
            pvIndex: -1,
            practiceTarget: null, 
            tempGame: null 
        };

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', () => {
            initBoard();
            initStockfish();
            loadSettings();
            if (!localStorage.getItem('gemini_api_key')) openSettings();
            setTimeout(() => { if(board) board.resize(); }, 300);
        });

        // --- 1. BOARD & PIECES ---
        function pieceTheme(piece) {
            return 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/' + piece.toLowerCase() + '.png';
        }

        function initBoard() {
            board = Chessboard('board', {
                position: 'start',
                draggable: false, 
                pieceTheme: pieceTheme,
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });
            window.addEventListener('resize', () => {
                board.resize();
                updateUI(); 
            });
        }
        
        function flipBoard() {
            if(board) board.flip();
            updateUI();
        }

        function toggleHeatmap() {
            isHeatmapActive = !isHeatmapActive;
            updateUI();
        }

        // --- 2. STOCKFISH ENGINE ---
        function initStockfish() {
            try {
                const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
                stockfish = new Worker(URL.createObjectURL(blob));
                stockfish.postMessage('uci');
                stockfish.postMessage('setoption name UCI_ShowWDL value true');
                stockfish.postMessage('setoption name MultiPV value 10');
            } catch (e) {
                console.error("Stockfish init failed:", e);
            }
        }

        // --- 3. GAME LOADING ---
        function loadPGN() {
            const btn = document.getElementById('loadPgnBtn');
            const originalText = btn.innerText;
            btn.innerText = "Loading...";

            setTimeout(() => {
                const pgn = document.getElementById('pgnInput').value.trim();
                if (!pgn) { btn.innerText = originalText; return; }

                try {
                    game.load_pgn(pgn) || game.load_pgn(pgn.replace(/\{.*?\}/g, '')) || game.load_pgn(pgn.replace(/\[.*?\]/g, ""));
                    
                    gameHistory = game.history({ verbose: true });

                    // --- AUTO ORIENTATION ---
                    const headers = game.header();
                    const username = localStorage.getItem('chess_username');
                    let orient = 'white';

                    if (username && headers) {
                        const userLower = username.toLowerCase();
                        if (headers['White'] && headers['White'].toLowerCase() === userLower) orient = 'white';
                        else if (headers['Black'] && headers['Black'].toLowerCase() === userLower) orient = 'black';
                    }

                    game.reset();
                    currentMoveIndex = -1;
                    board.position(game.fen());
                    board.orientation(orient);
                    
                    analysisData = [];
                    geminiComments = {};
                    gameStats = null;
                    stopInteractiveMode();
                    
                    updateUI();
                    document.getElementById('pgnModal').classList.add('hidden');
                    document.getElementById('gameStatus').innerText = "Game Loaded.";
                    document.getElementById('feedbackPlaceholder').innerHTML = '<i class="fa-solid fa-wand-magic-sparkles text-2xl mb-2 text-indigo-500"></i><br>Game Loaded.<br>Click <b>Review</b> for AI Analysis.';
                    document.getElementById('pgnInput').value = ''; 
                    
                } catch (e) {
                    alert("Invalid PGN.");
                } finally {
                    btn.innerText = originalText;
                }
            }, 50);
        }

        // --- 4. NAVIGATION & VISUALS ---
        function updateUI() {
            if(interactiveState.mode !== 'none') return;
            
            board.position(game.fen());
            
            const turn = game.turn();
            document.getElementById('turnIndicator').className = `w-3 h-3 rounded-full border-2 border-black ${turn === 'w' ? 'bg-white' : 'bg-black'}`;

            if(currentMoveIndex >= 0 && analysisData[currentMoveIndex] && analysisData[currentMoveIndex].opening) {
                document.getElementById('openingName').innerText = analysisData[currentMoveIndex].opening;
            }

            clearHeatmap();
            clearHighlights();
            clearArrows();

            if(isHeatmapActive) renderHeatmap();
            highlightLastMove();
            drawBestMoveArrow();

            updateCoachBox();
            updateEvalBar();
            updateStabilityBar();
        }

        function updateStabilityBar() {
            const container = document.getElementById('stabilityBar');
            if (!container) return;

            // 1. Perspective Management
            const turn = game.turn(); // 'w' or 'b'
            const indicator = document.getElementById('turnIndicatorIcon');
            if(indicator) {
                // Remove bg/border classes if any, set style directly for precision
                indicator.style.backgroundColor = turn === 'w' ? '#FFFFFF' : '#000000';
                indicator.style.borderColor = turn === 'w' ? '#000000' : '#FFFFFF';
                indicator.style.borderWidth = '2px';
                indicator.style.borderStyle = 'solid';
            }

            // 2. Hybrid Data Retrieval
            let segments = null;

            if (currentMoveIndex === -1) {
                // Start of game (White to move) -> Use Move 1's pre-stability if available
                if (analysisData.length > 0 && analysisData[0]) segments = analysisData[0].stability;
            } else if (currentMoveIndex < analysisData.length - 1) {
                // Mid-game -> Use Next Move's pre-stability
                if (analysisData[currentMoveIndex + 1]) segments = analysisData[currentMoveIndex + 1].stability;
            } else if (currentMoveIndex === analysisData.length - 1) {
                // Last played move -> We might have stored 'postMoveStability' in the last record?
                // If not, we rely on Live Analysis.
                if (analysisData[currentMoveIndex] && analysisData[currentMoveIndex].postMoveStability) {
                    segments = analysisData[currentMoveIndex].postMoveStability;
                }
            }

            // 3. Render Batch Data (Instant) or Placeholder
            renderStabilitySegments(segments || Array(10).fill('empty'));

            // 4. Trigger Live Analysis (Refinement)
            if (!isAnalyzing) {
                if (liveAnalysisDebounce) clearTimeout(liveAnalysisDebounce);
                liveAnalysisDebounce = setTimeout(liveAnalyzeCurrentPosition, 300);
            }
        }

        function renderStabilitySegments(segments) {
            const container = document.getElementById('stabilityBar');
            // Keep the indicator
            const indicator = document.getElementById('turnIndicatorIcon');
            container.innerHTML = '';
            if(indicator) container.appendChild(indicator);

            segments.forEach(color => {
                const div = document.createElement('div');
                div.className = `stability-segment stab-${color}`;
                container.appendChild(div);
            });
        }

        function highlightLastMove() {
            if (currentMoveIndex < 0) return;
            const move = gameHistory[currentMoveIndex];
            $('#board .square-' + move.from).addClass('highlight-last');
            $('#board .square-' + move.to).addClass('highlight-last');
        }
        
        function clearHighlights() {
            $('#board .square-55d63').removeClass('highlight-last');
        }

        function clearArrows() {
            const svg = document.getElementById('arrowOverlay');
            while(svg.lastChild) svg.removeChild(svg.lastChild);
        }

        function drawBestMoveArrow() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];
            
            if (data.classification !== "Best" && data.bestMoveSan && data.bestMove && data.bestMove !== '-') {
                const bestFrom = data.bestMove.substring(0,2);
                const bestTo = data.bestMove.substring(2,4);
                drawArrow(bestFrom, bestTo, '#22c55e'); 
            }
        }

        function drawArrow(from, to, color) {
            const $board = $('#board');
            const boardWidth = $board.width();
            const sqSize = boardWidth / 8;
            const orientation = board.orientation();
            const cols = 'abcdefgh';
            const rows = '87654321';
            
            const getCoords = (sq) => {
                let c = cols.indexOf(sq[0]);
                let r = rows.indexOf(sq[1]);
                if (orientation === 'black') { c = 7 - c; r = 7 - r; }
                return { x: c * sqSize + sqSize/2, y: r * sqSize + sqSize/2 };
            }

            const start = getCoords(from);
            const end = getCoords(to);
            const svg = document.getElementById('arrowOverlay');
            const id = `arrow-${from}-${to}`;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', end.x);
            line.setAttribute('y2', end.y);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', sqSize * 0.15);
            line.setAttribute('opacity', '0.6');
            line.setAttribute('marker-end', `url(#head-${id})`);
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', `head-${id}`);
            marker.setAttribute('markerWidth', '4');
            marker.setAttribute('markerHeight', '4');
            marker.setAttribute('refX', '2');
            marker.setAttribute('refY', '2');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L4,2 L0,4 Z');
            path.setAttribute('fill', color);
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);
            svg.appendChild(line);
        }

        function nextMove() {
            if(interactiveState.mode !== 'none') return;
            if (currentMoveIndex < gameHistory.length - 1) {
                currentMoveIndex++;
                game.move(gameHistory[currentMoveIndex]);
                updateUI();
            }
        }

        function prevMove() {
            if(interactiveState.mode !== 'none') return;
            if (currentMoveIndex >= 0) {
                game.undo();
                currentMoveIndex--;
                updateUI();
            }
        }

        function goToStart() {
            if(interactiveState.mode !== 'none') return;
            game.reset();
            currentMoveIndex = -1;
            updateUI();
        }

        function goToEnd() {
            if(interactiveState.mode !== 'none') return;
            while (currentMoveIndex < gameHistory.length - 1) {
                currentMoveIndex++;
                game.move(gameHistory[currentMoveIndex]);
            }
            updateUI();
        }

        // --- 5. VISUALS (HEATMAP & EVAL) ---
        function updateEvalBar() {
            let evalVal = 0.00;
            let wdlText = "";
            const barContainer = document.querySelector('.eval-bar-container');
            const barFill = document.getElementById('visualEvalBar');
            const evalTextEl = document.getElementById('evalText');
            const wdlEl = document.getElementById('wdlText');
            const textTop = document.getElementById('evalBarTextTop');
            const textBottom = document.getElementById('evalBarTextBottom');

            // 1. Handle Orientation
            const isFlipped = board && board.orientation() === 'black';
            if (barContainer) {
                barContainer.style.flexDirection = isFlipped ? 'column' : 'column-reverse';
            }
            
            if (currentMoveIndex >= 0 && analysisData[currentMoveIndex]) {
                const data = analysisData[currentMoveIndex];
                if (typeof data.eval === 'string' && data.eval.startsWith('M')) {
                    const mateIn = parseInt(data.eval.substring(1));
                    evalVal = mateIn > 0 ? 10 : -10; 
                    evalTextEl.innerText = `M${Math.abs(mateIn)}`;
                } else {
                    evalVal = parseFloat(data.eval);
                    const prefix = evalVal > 0 ? "+" : "";
                    evalTextEl.innerText = prefix + evalVal.toFixed(2);
                }
                if(data.wdl) {
                    const winP = (data.wdl[0] / 10).toFixed(0);
                    wdlText = `Win: ${winP}%`;
                    wdlEl.innerText = wdlText;
                    wdlEl.classList.remove('hidden');
                }
            } else {
                evalTextEl.innerText = "0.30";
                evalVal = 0.3;
                wdlEl.classList.add('hidden');
            }

            // 2. Calculate Fill
            const percentage = 50 + (Math.max(-5, Math.min(5, evalVal)) * 10); 
            barFill.style.height = `${percentage}%`;
            evalTextEl.style.color = percentage > 90 ? '#333' : (percentage < 10 ? '#fff' : '#999');

            // 3. Internal Bar Text Logic
            if (textTop && textBottom) {
                textTop.innerText = "";
                textBottom.innerText = "";

                let scoreStr = evalTextEl.innerText;
                let targetEl = null;
                let textColor = "";

                if (evalVal >= 0) {
                     // White Winning -> Text on White Area
                     // If Flipped (White Top): Text Top
                     // If Standard (White Bottom): Text Bottom
                     targetEl = isFlipped ? textTop : textBottom;
                     textColor = "#4b5563"; // Dark Gray on White
                } else {
                     // Black Winning -> Text on Black Area
                     // If Flipped (Black Bottom): Text Bottom
                     // If Standard (Black Top): Text Top
                     targetEl = isFlipped ? textBottom : textTop;
                     textColor = "#d1d5db"; // Light Gray on Dark
                }

                if (Math.abs(evalVal) > 0.1 || scoreStr.includes('M')) {
                     targetEl.innerText = scoreStr;
                     targetEl.style.color = textColor;
                }
            }
        }

        function renderHeatmap() {
            if(currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const report = analysisData[currentMoveIndex].control;
            if(!report || !report.exchange) return;

            const squares = ['a8','b8','c8','d8','e8','f8','g8','h8','a7','b7','c7','d7','e7','f7','g7','h7','a6','b6','c6','d6','e6','f6','g6','h6','a5','b5','c5','d5','e5','f5','g5','h5','a4','b4','c4','d4','e4','f4','g4','h4','a3','b3','c3','d3','e3','f3','g3','h3','a2','b2','c2','d2','e2','f2','g2','h2','a1','b1','c1','d1','e1','f1','g1','h1'];

            // Determine turn from stored data (it's the turn of the player who DID NOT just move in this position)
            // Actually, analysisData[i] is the state AFTER move i.
            // If move.color was 'w', it is now Black's turn.
            const turn = analysisData[currentMoveIndex].color === 'w' ? 'b' : 'w';

            squares.forEach((sq) => {
                const exchange = report.exchange[sq];
                if (!exchange) return;

                const $sq = $('#board .square-' + sq);
                let whiteScore = 0;

                if (exchange.status === 'Lost') {
                    // Current turn player has LOST control of this square
                    // If turn is Black, White controls it.
                    whiteScore = (turn === 'b') ? 3 : -3;
                } else {
                    // Use netValue (defVal - atkVal)
                    // It is from perspective of 'turn'
                    let val = exchange.netValue;

                    // Normalize to White perspective
                    if (turn === 'b') val = -val;

                    if (val >= 1) whiteScore = 1;
                    if (val >= 3) whiteScore = 2;
                    if (val >= 5) whiteScore = 3;

                    if (val <= -1) whiteScore = -1;
                    if (val <= -3) whiteScore = -2;
                    if (val <= -5) whiteScore = -3;
                }

                if (whiteScore > 0) {
                    if (whiteScore >= 3) $sq.addClass('square-control-w-3');
                    else if (whiteScore === 2) $sq.addClass('square-control-w-2');
                    else $sq.addClass('square-control-w-1');
                } else if (whiteScore < 0) {
                    if (whiteScore <= -3) $sq.addClass('square-control-b-3');
                    else if (whiteScore === -2) $sq.addClass('square-control-b-2');
                    else $sq.addClass('square-control-b-1');
                }
            });
        }

        function clearHeatmap() {
            $('#board .square-55d63').removeClass(function(index, className) {
                return (className.match(/(^|\s)square-control-\S+/g) || []).join(' ');
            });
        }

        // --- 6. COACH BOX LOGIC ---
        function updateCoachBox() {
            if(interactiveState.mode !== 'none') return;
            const contentDiv = document.getElementById('feedbackContent');
            const placeholder = document.getElementById('feedbackPlaceholder');
            const box = document.getElementById('coachBox');
            const badge = document.getElementById('moveClassBadge');
            const tacticBadge = document.getElementById('tacticsBadge');
            const suggestionDiv = document.getElementById('bestMoveSuggestion');
            const bestMoveText = document.getElementById('bestMoveText');

            if (analysisData.length === 0 || currentMoveIndex === -1) {
                // Check if we have Game Stats to show (Post-Analysis State)
                if (gameStats) {
                    contentDiv.classList.add('hidden');
                    placeholder.classList.remove('hidden');
                    box.className = 'coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center border-l-8 border-indigo-500 bg-indigo-50';

                    // Render Game Summary Card
                    placeholder.innerHTML = `
                        <div class="text-left w-full">
                            <h3 class="font-bold text-indigo-800 border-b border-indigo-200 pb-1 mb-2">Game Summary</h3>
                            <div class="grid grid-cols-2 gap-4 text-sm mb-2">
                                <div>
                                    <div class="text-xs text-gray-500 uppercase font-bold">Accuracy</div>
                                    <div class="font-bold text-gray-800">${gameStats.accuracyLabel}</div>
                                    <div class="text-xs text-gray-400">ACPL: ${gameStats.acpl}</div>
                                </div>
                                <div>
                                    <div class="text-xs text-gray-500 uppercase font-bold">Style</div>
                                    <div class="font-bold text-gray-800">${gameStats.styleLabel}</div>
                                    <div class="text-xs text-gray-400">Complexity: ${gameStats.complexity}</div>
                                </div>
                            </div>
                            <div class="text-xs text-indigo-600 bg-white p-2 rounded border border-indigo-100 italic">
                                <i class="fa-solid fa-robot"></i> Use the arrows to review move-by-move.
                            </div>
                        </div>
                    `;
                    return;
                }

                // Default Start State
                contentDiv.classList.add('hidden');
                placeholder.classList.remove('hidden');
                placeholder.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles text-2xl mb-2 text-indigo-500"></i><br>Game Loaded.<br>Click <b>Review</b> for AI Analysis.';
                box.className = 'coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center'; 
                return;
            }

            contentDiv.classList.remove('hidden');
            placeholder.classList.add('hidden');

            const data = analysisData[currentMoveIndex];
            const moveNotation = `${Math.floor(currentMoveIndex / 2) + 1}${data.color === 'w' ? '.' : '...'} ${data.san}`;

            badge.innerText = data.classification;
            badge.className = `classification-badge bg-${data.classification.toLowerCase()}`;
            box.className = `coach-box ${data.classification.toLowerCase()} p-4 rounded-r-lg shadow-sm flex flex-col justify-center`;

            if(data.tactic) {
                tacticBadge.innerText = data.tactic.toUpperCase();
                tacticBadge.classList.remove('hidden');
            } else {
                tacticBadge.classList.add('hidden');
            }

            let commentData = geminiComments[currentMoveIndex + 1];
            let mainComment = "Standard move.";
            
            if (commentData) {
                if (typeof commentData === 'string') mainComment = commentData;
                else if (commentData.analysis) mainComment = commentData.analysis;
            } else {
                if (data.classification === "Best") mainComment = "Excellent find!";
                else if (data.classification === "Mistake") mainComment = "This loses advantage.";
                else if (data.classification === "Blunder") mainComment = "Critical error.";
                else if (data.classification === "Book") mainComment = "Standard opening theory.";
            }
            
            document.getElementById('coachText').innerHTML = marked.parse(mainComment);
            document.getElementById('moveNumber').innerText = moveNotation;

            const needsSuggestion = ["Inaccuracy", "Mistake", "Miss", "Blunder"].includes(data.classification);
            
            if (needsSuggestion && data.bestMoveSan && data.pv) {
                suggestionDiv.classList.remove('hidden');
                bestMoveText.innerText = data.bestMoveSan;
            } else {
                suggestionDiv.classList.add('hidden');
            }
        }

        // --- 7. INTERACTIVE MODES ---
        function stopInteractiveMode() {
            interactiveState.mode = 'none';
            interactiveState.tempGame = null;
            document.getElementById('coachBox').classList.remove('pv-active', 'practice-active');
            document.getElementById('board').classList.remove('board-pv-highlight', 'board-practice-mode');
            document.getElementById('pvModeBadge').classList.add('hidden');
            document.getElementById('practiceModeBadge').classList.add('hidden');
            document.getElementById('mainNavButtons').style.opacity = '1';
            document.getElementById('mainNavButtons').style.pointerEvents = 'auto';
            if(board) board.draggable = false; 
            updateUI();
        }

        function startPvReview() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];
            if (!data.pv) return;

            interactiveState.mode = 'pv';
            interactiveState.tempGame = new Chess(data.fenBefore);
            interactiveState.pvIndex = -1;
            interactiveState.pvMoves = [];
            const moveStrings = data.pv.split(' ');
            const limit = Math.min(moveStrings.length, 6);
            
            for(let i=0; i<limit; i++) {
                const m = moveStrings[i];
                const from = m.substring(0,2);
                const to = m.substring(2,4);
                const promotion = m.length > 4 ? m.substring(4,5) : 'q';
                const moveObj = interactiveState.tempGame.move({from, to, promotion});
                if(moveObj) interactiveState.pvMoves.push(moveObj);
                else break; 
            }
            interactiveState.tempGame.reset();
            interactiveState.tempGame.load(data.fenBefore);

            const geminiData = geminiComments[currentMoveIndex + 1];
            interactiveState.pvComments = (geminiData && geminiData.pv_explanation) ? geminiData.pv_explanation : [];

            document.getElementById('coachBox').classList.add('pv-active');
            document.getElementById('board').classList.add('board-pv-highlight');
            document.getElementById('pvModeBadge').classList.remove('hidden');
            document.getElementById('mainNavButtons').style.opacity = '0.5';
            document.getElementById('mainNavButtons').style.pointerEvents = 'none';

            board.position(data.fenBefore);
            clearArrows(); 
            updatePvUI();
        }

        function nextPvMove() {
            if (interactiveState.mode !== 'pv') return;
            if (interactiveState.pvIndex < interactiveState.pvMoves.length - 1) {
                interactiveState.pvIndex++;
                const m = interactiveState.pvMoves[interactiveState.pvIndex];
                interactiveState.tempGame.move(m);
                board.position(interactiveState.tempGame.fen());
                clearArrows();
                drawArrow(m.from, m.to, '#6366f1'); 
                updatePvUI();
            }
        }

        function prevPvMove() {
            if (interactiveState.mode !== 'pv') return;
            if (interactiveState.pvIndex >= 0) {
                interactiveState.tempGame.undo();
                interactiveState.pvIndex--;
                board.position(interactiveState.tempGame.fen());
                clearArrows();
                updatePvUI();
            }
        }

        function updatePvUI() {
            const indicator = document.getElementById('pvMoveIndicator');
            const commentText = document.getElementById('pvCommentText');
            
            if (interactiveState.pvIndex === -1) {
                indicator.innerText = "Start";
                commentText.innerHTML = "<b>Initial Position.</b><br>Click > to see why this is better.";
            } else {
                const moveObj = interactiveState.pvMoves[interactiveState.pvIndex];
                indicator.innerText = `Move ${interactiveState.pvIndex + 1}`;
                let comment = interactiveState.pvComments[interactiveState.pvIndex] || "Continuing the best line.";
                commentText.innerHTML = `<b>${moveObj.san}:</b> ${comment}`;
            }
        }

        function startPracticeMode() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];

            interactiveState.mode = 'practice';
            interactiveState.tempGame = new Chess(data.fenBefore);
            interactiveState.practiceTarget = data.bestMove; 

            document.getElementById('coachBox').classList.add('practice-active');
            document.getElementById('board').classList.add('board-practice-mode');
            document.getElementById('practiceModeBadge').classList.remove('hidden');
            document.getElementById('mainNavButtons').style.opacity = '0.5';
            document.getElementById('mainNavButtons').style.pointerEvents = 'none';
            document.getElementById('practiceFeedbackText').innerText = "Drag the pieces to find the best move!";
            document.getElementById('practiceFeedbackText').className = "text-sm text-gray-800 font-medium mb-3 min-h-[40px] flex items-center justify-center text-center";

            board.position(data.fenBefore);
            clearArrows();
            
            board = Chessboard('board', {
                position: data.fenBefore,
                draggable: true,
                pieceTheme: pieceTheme,
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });
            if(game.turn() === 'b') board.orientation('black');
            else board.orientation('white');
        }

        function onDragStart (source, piece, position, orientation) {
            if (interactiveState.mode !== 'practice') return false;
            if ((interactiveState.tempGame.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (interactiveState.tempGame.turn() === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }

        function onDrop (source, target) {
            if (interactiveState.mode !== 'practice') return 'snapback';
            var move = interactiveState.tempGame.move({ from: source, to: target, promotion: 'q' });
            if (move === null) return 'snapback';

            const uciMove = source + target + (move.promotion ? move.promotion : '');
            const targetUci = interactiveState.practiceTarget;
            const isCorrect = uciMove.includes(targetUci) || targetUci.includes(uciMove);

            if (isCorrect) {
                document.getElementById('practiceFeedbackText').innerHTML = "<span class='text-green-600 font-bold text-lg'><i class='fa-solid fa-check'></i> Correct!</span>";
                document.getElementById('board').classList.add('practice-success');
                setTimeout(() => {
                    alert("Great job! You found the best move.");
                    stopInteractiveMode();
                    initBoard();
                    updateUI();
                }, 500);
            } else {
                document.getElementById('practiceFeedbackText').innerHTML = "<span class='text-red-500 font-bold'><i class='fa-solid fa-xmark'></i> Incorrect. Try again.</span>";
                document.getElementById('board').classList.add('practice-fail');
                setTimeout(() => document.getElementById('board').classList.remove('practice-fail'), 500);
                interactiveState.tempGame.undo(); 
                return 'snapback';
            }
        }

        function onSnapEnd () {}

        // --- 8. ANALYSIS PIPELINE (UPDATED LOGIC) ---
        async function startAnalysis() {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) { alert("Please add API Key."); openSettings(); return; }
            
            isAnalyzing = true;
            const overlay = document.getElementById('analysisOverlay');
            overlay.classList.remove('hidden');
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressBar').style.width = "0%";
            document.getElementById('geminiStatus').classList.add('hidden');

            const tempGame = new Chess();
            analysisData = [];
            let openingName = "Unknown Opening";

            try {
                for (let i = 0; i < gameHistory.length; i++) {
                    if (!isAnalyzing) return; 

                    const move = gameHistory[i];
                    document.getElementById('progressBar').style.width = Math.round(((i+1)/gameHistory.length)*100) + "%";
                    document.getElementById('progressText').innerText = `Analyzing Move ${i+1}/${gameHistory.length}`;

                    const fenBefore = tempGame.fen();
                    
                    // --- BOOK CHECK ---
                    let bookMoves = [];
                    let isBook = false;
                    if (i < 15) { 
                        const bookResult = await fetchBookData(fenBefore);
                        if (bookResult) {
                            bookMoves = bookResult.moves.map(m => m.uci);
                            if (bookResult.opening) openingName = bookResult.opening.name;
                            const userUci = move.from + move.to + (move.promotion || '');
                            if (bookMoves.includes(userUci)) isBook = true;
                        }
                    }
                    
                    let tablebaseData = (getPieceCount(fenBefore) <= 7) ? await fetchTablebase(fenBefore) : null;

                    // 1. ENGINE BEFORE
                    const preMoveResult = await runStockfish(fenBefore);
                    let scoreBefore = parseEvalToNumber(preMoveResult.eval);
                    
                    // --- STABILITY & CRITICAL MOMENT LOGIC ---
                    let isCritical = false;
                    let stabilityData = calculateStabilitySegments(preMoveResult.lines, tempGame.turn());

                    if (preMoveResult.lines && preMoveResult.lines.length >= 2) {
                        const l1 = preMoveResult.lines[0];
                        const l2 = preMoveResult.lines[1];
                        const s1 = getGapScore(l1);
                        const s2 = getGapScore(l2);
                        if (Math.abs(s1 - s2) > 150) isCritical = true;
                    }

                    // Handle Tablebase "Truth"
                    const turnBefore = tempGame.turn();
                    if (tablebaseData === 'win') scoreBefore = (turnBefore === 'w') ? 100 : -100;
                    if (tablebaseData === 'loss') scoreBefore = (turnBefore === 'w') ? -100 : 100;

                    // 2. SIMULATE BEST MOVE
                    let bestMoveStats = { matDiff:0, centerCtrl:0, safety:0, rawMaterial:0 };
                    let bestMoveSan = preMoveResult.bestMove;
                    let bestLineSan = "";
                    let bestIsMate = preMoveResult.eval.toString().startsWith("M");

                    if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                        const simGame = new Chess(fenBefore);
                        const bm = simGame.move({ from: preMoveResult.bestMove.substring(0,2), to: preMoveResult.bestMove.substring(2,4), promotion: 'q' });
                        if(bm) {
                            bestMoveSan = bm.san;
                            bestMoveStats = getDetailedMoveStats(simGame, bm, fenBefore);
                        }
                        if(preMoveResult.pv) bestLineSan = uciToSan(fenBefore, preMoveResult.pv);
                    }

                    // 3. EXECUTE USER MOVE
                    tempGame.move(move.san);
                    const fenAfter = tempGame.fen();
                    const userMoveStats = getDetailedMoveStats(tempGame, move, fenBefore);

                    // 4. POST MOVE ANALYSIS
                    const isMate = tempGame.in_checkmate();
                    const isDraw = tempGame.in_draw() || tempGame.in_stalemate();
                    let scoreAfter = 0;
                    let evAfterStr = "";
                    let postMoveStability = Array(10).fill('empty');
                    
                    if (isMate) {
                        scoreAfter = (move.color === 'w') ? 100 : -100;
                        evAfterStr = "M0"; 
                        postMoveStability = Array(10).fill('red');
                    } else if (isDraw) {
                        scoreAfter = 0;
                        evAfterStr = "0.00";
                    } else {
                        const postMoveResult = await runStockfish(fenAfter);
                        evAfterStr = postMoveResult.eval;
                        scoreAfter = parseEvalToNumber(postMoveResult.eval);
                        postMoveStability = calculateStabilitySegments(postMoveResult.lines, tempGame.turn());
                    }

                    // --- CLASSIFICATION LOGIC FIXES ---
                    let cls = "Neutral";
                    let evalDiff = (move.color === 'w') ? (scoreBefore - scoreAfter) : (scoreAfter - scoreBefore);

                    // Context Flags
                    const isUserWinning = (move.color === 'w' && scoreBefore > 10) || (move.color === 'b' && scoreBefore < -10);
                    const isUserLost = (move.color === 'w' && scoreBefore < -10) || (move.color === 'b' && scoreBefore > 10);
                    const userFoundMate = evAfterStr.toString().startsWith("M") && ((move.color === 'w' && scoreAfter > 0) || (move.color === 'b' && scoreAfter < 0));

                    // 1. Absolute Truths
                    if (isMate) {
                         cls = "Best"; 
                    } 
                    else if (scoreAfter === -100 || (evAfterStr.toString().startsWith('M') && !userFoundMate)) {
                         cls = "Blunder"; // Forced mate detected against user
                    }
                    else if (isBook) {
                         cls = "Book";
                    }
                    else if (move.san === bestMoveSan) {
                         cls = "Best";
                    }
                    // 2. "Mate Optimization" (Don't punish finding a slower mate)
                    else if (bestIsMate && userFoundMate) {
                         cls = "Excellent";
                    }
                    // 3. "Resignation Threshold" (Don't analyze blunders in lost positions)
                    else if (isUserLost) {
                         if (evalDiff > 5) cls = "Mistake"; 
                         else cls = "Neutral";
                    }
                    // 4. "Winning Cushion" (Don't analyze inaccuracies when winning huge)
                    else if (isUserWinning) {
                         if (evalDiff > 5) cls = "Mistake"; 
                         else cls = "Good"; 
                    }
                    else {
                         // Standard Mid-Game Logic
                         if (evalDiff <= 0.3) cls = "Best";
                         else if (evalDiff <= 0.8) cls = "Excellent";
                         else if (evalDiff <= 1.5) cls = "Good";
                         else if (evalDiff <= 2.5) cls = "Inaccuracy"; 
                         else if (evalDiff <= 4.0) cls = "Mistake"; 
                         else cls = "Blunder"; 
                    }

                    // --- ENHANCED MATERIAL LOGIC ---
                    const startMaterial = getMaterialScore(fenBefore);
                    const userMaterial = userMoveStats.rawMaterial; // From getDetailedMoveStats
                    const bestMaterial = bestMoveStats.rawMaterial; // From getDetailedMoveStats

                    // Calculate absolute changes for the current mover
                    let userGain = (move.color === 'w') ? (userMaterial - startMaterial) : (startMaterial - userMaterial);
                    let bestGain = (move.color === 'w') ? (bestMaterial - startMaterial) : (startMaterial - bestMaterial);

                    // Check protection using the state AFTER the move
                    const isProtected = isSquareProtected(tempGame, move.to);
                    const isCapture = move.flags.includes('c') || move.captured;

                    let materialMsg = "";

                    if (userGain < 0 && bestGain >= 0) {
                        materialMsg = !isProtected ? "HUNG_PIECE" : "BAD_TRADE";
                    } else if (userGain === 0 && (cls === "Mistake" || cls === "Blunder") && isCapture) {
                        materialMsg = "TRADED_AWAY_ADVANTAGE";
                    } else if (bestGain > 0 && userGain <= 0 && Math.abs(bestGain - userGain) >= 1) {
                        materialMsg = "MISSED_WIN";
                    } else if ((cls === "Mistake" || cls === "Blunder") && userGain >= 0) {
                        materialMsg = "POSITIONAL_BLUNDER";
                    }

                    const tacticAlert = isMate ? "Checkmate" : detectTactics(tempGame, move);

                    analysisData.push({
                        eval: evAfterStr, 
                        wdl: preMoveResult.wdl,
                        bestMove: preMoveResult.bestMove,
                        bestMoveSan: bestMoveSan,
                        pv: preMoveResult.pv,
                        pvSan: bestLineSan,
                        san: move.san,
                        color: move.color,
                        classification: cls,
                        fenBefore: fenBefore,
                        opening: openingName,
                        tactic: tacticAlert,
                        control: HeatMap.analyze(tempGame),
                        isMate: isMate,
                        isCritical: isCritical,
                        stability: stabilityData,
                        postMoveStability: postMoveStability,
                        stats: { user: userMoveStats, best: bestMoveStats },
                        materialStatus: materialMsg
                    });
                }

                if (!isAnalyzing) return;

                // =========================================================
                // === NEW AGGREGATION BLOCK: Calculate Game Character ===
                // =========================================================

                let whiteLoss = 0, whiteMoves = 0;
                let blackLoss = 0, blackMoves = 0;
                let whiteBlunders = 0, blackBlunders = 0;
                let complexitySum = 0;
                let stabilitySum = 0;
                let prevEval = 0;

                const ACPL_MAP = {
                    "Best": 0, "Excellent": 5, "Good": 20,
                    "Inaccuracy": 60, "Mistake": 150, "Blunder": 350, "Neutral": 0, "Book": 0
                };

                analysisData.forEach(d => {
                    // Stability
                    if (d.stability) {
                        stabilitySum += d.stability.filter(s => s === 'green').length;
                    }

                    // ACPL
                    const loss = ACPL_MAP[d.classification] || 0;
                    if (d.color === 'w') {
                        whiteLoss += loss;
                        whiteMoves++;
                        if (d.classification === 'Blunder') whiteBlunders++;
                    } else {
                        blackLoss += loss;
                        blackMoves++;
                        if (d.classification === 'Blunder') blackBlunders++;
                    }

                    // Complexity
                    let currentEval = parseEvalToNumber(d.eval);
                    if (d.eval.toString().includes('M')) currentEval = d.eval.includes('-') ? -20 : 20;

                    // Normalize swing (cap at 4.0 per move to prevent single blunders skewing everything)
                    let swing = Math.abs(currentEval - prevEval);
                    if (swing > 4.0) swing = 4.0;

                    complexitySum += swing;
                    prevEval = currentEval;
                });

                const whiteAcpl = Math.round(whiteLoss / (whiteMoves || 1));
                const blackAcpl = Math.round(blackLoss / (blackMoves || 1));

                // Scale complexity to 0-5 roughly
                // Average swing of 0.5 is calm, 1.5 is sharp.
                // (Sum / Moves) * 2.5 roughly maps 0-2 range to 0-5
                let rawComp = complexitySum / (analysisData.length || 1);
                let complexityScore = (rawComp * 2.5).toFixed(1);
                if (complexityScore > 5.0) complexityScore = "5.0";

                let avgStability = (stabilitySum / (analysisData.length || 1)).toFixed(1);

                const whiteAcc = calculateAccuracy(whiteAcpl);
                const blackAcc = calculateAccuracy(blackAcpl);

                const whiteArch = getArchetype(whiteAcc, complexityScore, whiteBlunders);
                const blackArch = getArchetype(blackAcc, complexityScore, blackBlunders);

                // Store stats for UI
                gameStats = {
                    white: { acpl: whiteAcpl, accuracy: whiteAcc, archetype: whiteArch },
                    black: { acpl: blackAcpl, accuracy: blackAcc, archetype: blackArch },
                    complexity: complexityScore,
                    avgStability: avgStability,
                    // Legacy support for summary card (can be removed later if card is updated)
                    accuracyLabel: whiteAcc + "% vs " + blackAcc + "%",
                    acpl: whiteAcpl,
                    styleLabel: complexityScore > 2.5 ? "Sharp" : "Positional"
                };

                // Generate and Save (ID handled by saveGameToLibrary)
                const gameToSave = {
                    pgn: game.pgn(),
                    opening: openingName,
                    date: new Date().toLocaleDateString(),
                    analysisData: analysisData,
                    gameStats: gameStats,
                    geminiComments: {} // Placeholder
                };
                saveGameToLibrary(gameToSave);

                // Update Header immediately
                if (typeof updateMatchHeader === 'function') {
                    updateMatchHeader(gameStats.white, gameStats.black, gameStats.complexity);
                }

                const gameSummary = `
[GAME SUMMARY]
- White: ${whiteArch.label} (${whiteAcc}% Accuracy, ${whiteAcpl} ACPL)
- Black: ${blackArch.label} (${blackAcc}% Accuracy, ${blackAcpl} ACPL)
- Complexity: ${complexityScore}/5.0
`;

                document.getElementById('statusTitle').innerText = "Consulting Coach...";
                document.getElementById('geminiStatus').classList.remove('hidden');
                document.getElementById('progressBar').className = "h-full bg-purple-500 animate-pulse";
                await getGeminiCommentary(apiKey, document.getElementById('analysisFocus').value, openingName, gameSummary);

                // Update saved game with comments
                gameToSave.geminiComments = geminiComments;
                saveGameToLibrary(gameToSave);

            } catch (err) {
                console.error(err);
                alert("Analysis Error: " + err.message);
            } finally {
                overlay.classList.add('hidden');
                document.getElementById('analyzeBtn').disabled = false;
                isAnalyzing = false;
                if (analysisData.length > 0) {
                   if(currentMoveIndex === -1) nextMove(); 
                   else updateUI();
                }
            }
        }

        function runStockfish(fen) {
            return new Promise(resolve => {
                if (!stockfish) initStockfish();
                const tId = setTimeout(() => resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null, lines: [] }), 4000);
                stockfish.postMessage('stop');
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth 12'); 

                let best="-", ev="0.00", pv="", wdl=null;
                let lines = [];

                const list = (e) => {
                    const l = e.data;

                    if (l.startsWith('info') && l.includes('multipv') && l.includes('score')) {
                        const matchPv = l.match(/multipv (\d+)/);
                        const matchScore = l.match(/score (cp|mate) (-?\d+)/);
                        const matchPvStr = l.split(' pv ')[1];

                        if (matchPv && matchScore && matchPvStr) {
                            const lineIdx = parseInt(matchPv[1]) - 1;
                            let rawVal = parseInt(matchScore[2]);
                            let absScore = (fen.includes(' b ') ? -rawVal : rawVal);
                            let scoreStr = (matchScore[1] === 'mate') ? "M" + absScore : (absScore / 100).toFixed(2);

                            lines[lineIdx] = {
                                score: scoreStr,
                                pv: matchPvStr,
                                rawScore: absScore,
                                type: matchScore[1]
                            };

                            if (lineIdx === 0) {
                                pv = matchPvStr;
                                ev = scoreStr;
                            }
                        }
                    }

                    if (l.includes(' wdl ')) { const m=l.match(/wdl (\d+) (\d+) (\d+)/); if(m) wdl=[parseInt(m[1]), parseInt(m[2]), parseInt(m[3])]; }

                    if (l.startsWith('bestmove')) {
                        clearTimeout(tId);
                        best = l.split(' ')[1];
                        stockfish.removeEventListener('message', list);

                        if (lines.length === 0) {
                             let fallbackRaw = parseFloat(ev) * 100;
                             if(ev.toString().startsWith('M')) fallbackRaw = parseInt(ev.substring(1));
                             lines.push({ score: ev, pv: pv, rawScore: fallbackRaw, type: ev.toString().startsWith('M')?'mate':'cp' });
                        }

                        if(!wdl && !ev.toString().startsWith('M')) wdl = estimateWDL(parseFloat(ev));
                        resolve({ eval: ev, bestMove: best, pv: pv, wdl: wdl, lines: lines });
                    }
                };
                stockfish.addEventListener('message', list);
            });
        }

        // --- STABILITY MATH HELPER ---
        function calculateStabilitySegments(lines, turn) {
            // lines: Array of { rawScore: number, type: 'cp'|'mate', ... }
            // turn: 'w' or 'b'

            if (!lines || lines.length === 0) return Array(10).fill('empty');

            const getScore = (l) => {
                if (l.type === 'mate') {
                    // Normalize Mate to +/- 10000.
                    return l.rawScore > 0 ? 10000 : -10000;
                }
                return l.rawScore; // Centipawns
            };

            // Find the Best Score among lines
            let bestScore = getScore(lines[0]);
            for(let l of lines) {
                const s = getScore(l);
                if (turn === 'w') { if(s > bestScore) bestScore = s; }
                else { if(s < bestScore) bestScore = s; }
            }

            let rawSegments = [];

            for(let i=0; i<lines.length; i++) {
                const l = lines[i];
                const s = getScore(l);

                // Calculate "Distance from Best"
                let diffCp = (turn === 'w') ? (bestScore - s) : (s - bestScore);
                if (diffCp < 0) diffCp = 0;
                const diffPawns = diffCp / 100.0;

                if (diffPawns < 0.5) rawSegments.push('green');
                else if (diffPawns <= 2.0) rawSegments.push('yellow');
                else rawSegments.push('red');
            }

            // SORTING LOGIC: Green (Best) -> Yellow -> Red -> Empty
            // Precedence map: green=1, yellow=2, red=3
            const precedence = { 'green': 1, 'yellow': 2, 'red': 3 };

            rawSegments.sort((a, b) => precedence[a] - precedence[b]);

            // Fill remainder with empty
            while (rawSegments.length < 10) {
                rawSegments.push('empty');
            }

            // Limit to 10 just in case
            return rawSegments.slice(0, 10);
        }

        // --- LIVE ANALYSIS HELPER ---
        const getGapScore = (line) => {
            if (line.type === 'mate') return line.rawScore > 0 ? 10000 : -10000;
            return line.rawScore;
        };

        function liveAnalyzeCurrentPosition() {
            // 1. Safety Checks: Don't run if analyzing a full game or engine isn't ready
            if (isAnalyzing || !stockfish) return;

            const fen = game.fen();
            const turn = game.turn();

            // 2. Reset Engine for Live Analysis
            stockfish.postMessage('stop');
            stockfish.postMessage('position fen ' + fen);
            stockfish.postMessage('go multipv 10'); // Ask for 10 lines

            let lastUpdate = 0;
            let liveLines = [];
            let hasShownFullBar = false;

            // Calculate expected lines (legal moves capped at 10)
            const legalMovesCount = game.moves().length;
            const targetLines = Math.min(10, legalMovesCount);

            // 3. Clean up old listeners to prevent memory leaks/duplicate updates
            if (window._currentLiveListener) {
                stockfish.removeEventListener('message', window._currentLiveListener);
            }

            const liveListener = (e) => {
                if (isAnalyzing) {
                    stockfish.removeEventListener('message', liveListener);
                    return;
                }

                const l = e.data;

                // 4. Parse Engine Output
                if (l.startsWith('info') && l.includes('multipv') && l.includes('score')) {
                    const matchPv = l.match(/multipv (\d+)/);
                    const matchScore = l.match(/score (cp|mate) (-?\d+)/);

                    if (matchPv && matchScore) {
                        const idx = parseInt(matchPv[1]) - 1;
                        let rawVal = parseInt(matchScore[2]);
                        let absScore = (fen.includes(' b ') ? -rawVal : rawVal);

                        // Store the line data
                        liveLines[idx] = {
                            rawScore: absScore,
                            type: matchScore[1]
                        };

                        // 5. THE FIX: Smart Throttling
                        const now = Date.now();
                        const validLineCount = liveLines.filter(line => line).length;

                        let shouldRender = false;

                        // Case 1: Target reached for the first time -> Render Immediately
                        if (validLineCount >= targetLines && !hasShownFullBar) {
                            shouldRender = true;
                            hasShownFullBar = true;
                        }
                        // Case 2: Standard Throttle (Wait 1s, but show partials if we have enough data)
                        else if (validLineCount >= Math.min(4, targetLines) && (now - lastUpdate > 1000)) {
                             shouldRender = true;
                        }

                        if (shouldRender) {
                             const segs = calculateStabilitySegments(liveLines, turn);
                             renderStabilitySegments(segs);
                             lastUpdate = now;
                        }
                    }
                }
            };

            window._currentLiveListener = liveListener;

            stockfish.addEventListener('message', liveListener);
        }

        // --- 9. HELPERS ---
        function toggleSidebar() {
            const sidebar = document.getElementById('librarySidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const isClosed = sidebar.classList.contains('-translate-x-full');

            if (isClosed) {
                sidebar.classList.remove('-translate-x-full');
                overlay.classList.remove('hidden');
                renderGameList();
            } else {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
            }
        }

        function renderGameList() {
            const list = JSON.parse(localStorage.getItem('chess_coach_library') || '[]');
            const container = document.getElementById('gameListContainer');

            if (list.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 mt-10 text-sm italic">No games saved yet.</div>';
                return;
            }

            // Reverse to show newest first
            container.innerHTML = [...list].reverse().map(g => {
                let resultBadge = '';
                if (g.gameStats && g.analysisData && g.analysisData.length > 0) {
                    const last = g.analysisData[g.analysisData.length - 1];
                    let score = "-";
                    let colorClass = "bg-gray-400";

                    if (last.isMate || last.eval.toString().startsWith('M') || parseFloat(last.eval) > 10 || parseFloat(last.eval) < -10) {
                         const evalNum = typeof last.eval === 'string' && last.eval.startsWith('M') ? (last.eval.includes('-') ? -100 : 100) : parseFloat(last.eval);
                         if (evalNum > 0) { score = "1-0"; colorClass = "bg-green-500"; }
                         else { score = "0-1"; colorClass = "bg-red-500"; }
                    }
                    resultBadge = `<div class="flex items-center gap-1 text-[10px] font-bold text-gray-600 bg-gray-100 px-2 py-1 rounded border border-gray-200">
                        ${score} <span class="w-2 h-2 rounded-full ${colorClass}"></span>
                    </div>`;
                }

                // Calculate Stability Badge
                let stabBadge = "";
                if (g.gameStats && g.gameStats.avgStability) {
                    const s = parseFloat(g.gameStats.avgStability);
                    if (s >= 7) stabBadge = `<span class="flex items-center gap-1 text-[9px] font-bold text-gray-500 uppercase"><div class="w-2 h-2 rounded-full bg-green-500"></div> Solid</span>`;
                    else if (s >= 4) stabBadge = `<span class="flex items-center gap-1 text-[9px] font-bold text-gray-500 uppercase"><div class="w-2 h-2 rounded-full bg-yellow-500"></div> Tactical</span>`;
                    else stabBadge = `<span class="flex items-center gap-1 text-[9px] font-bold text-gray-500 uppercase"><div class="w-2 h-2 rounded-full bg-red-500"></div> Volatile</span>`;
                }

                return `
                <div onclick="loadGameFromLibrary('${g.id}')" class="bg-white p-3 rounded-lg shadow-sm border border-gray-200 hover:border-indigo-300 hover:shadow-md cursor-pointer transition-all relative group">
                    <div class="flex justify-between items-start mb-1">
                        <div class="text-[10px] text-gray-400 font-mono uppercase tracking-wide">${g.date}</div>
                        ${resultBadge}
                    </div>
                    <div class="font-bold text-gray-800 text-sm mb-2 truncate leading-tight">${g.opening || 'Unknown Opening'}</div>
                    <div class="flex justify-between items-center border-t border-gray-100 pt-2">
                         <div class="flex gap-2">
                            <div class="text-[10px] font-bold px-2 py-1 rounded bg-purple-50 text-purple-700 border border-purple-100">
                                Chaos: ${g.gameStats ? g.gameStats.complexity : '?'}
                            </div>
                            ${stabBadge}
                         </div>
                         <div class="text-indigo-400 group-hover:text-indigo-600 transition-colors"><i class="fa-solid fa-chevron-right text-xs"></i></div>
                    </div>
                </div>
            `;
            }).join('');
        }

        function calculateAccuracy(acpl) {
            return Math.max(0, 100.0 - (2.0 * Math.sqrt(acpl))).toFixed(1);
        }

        function getArchetype(accuracy, complexity, blunderCount) {
            const acc = parseFloat(accuracy);
            const cplx = parseFloat(complexity);
            const blunders = parseInt(blunderCount);

            if (acc > 95) return { label: "The Engine", icon: "fa-microchip" };
            if (acc >= 90 && acc <= 95 && blunders === 0) return { label: "The Grandmaster", icon: "fa-chess-king" };
            if (acc > 85 && cplx > 3.0) return { label: "The Magician", icon: "fa-wand-magic-sparkles" };
            if (acc >= 80 && acc <= 90 && cplx < 1.5) return { label: "The Solid Pro", icon: "fa-shield-halved" };
            if (acc < 70 && cplx > 3.0) return { label: "The Gambler", icon: "fa-dice" };
            if (acc < 70) return { label: "The Student", icon: "fa-user-graduate" };

            return { label: "The Club Player", icon: "fa-users" };
        }

        function getPgnHash(pgn) {
            let hash = 0;
            const cleanPgn = pgn.replace(/\s+/g, ' ').trim();
            if (cleanPgn.length === 0) return hash;
            for (let i = 0; i < cleanPgn.length; i++) {
                const char = cleanPgn.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16);
        }

        function saveGameToLibrary(gameData) {
            const STORAGE_KEY = 'chess_coach_library';
            let library = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

            const currentHash = getPgnHash(gameData.pgn);
            const existingIndex = library.findIndex(g => getPgnHash(g.pgn) === currentHash);

            if (existingIndex !== -1) {
                // Overwrite existing analysis but preserve ID and Date
                const existing = library[existingIndex];
                library[existingIndex] = {
                    ...gameData,
                    id: existing.id,
                    date: existing.date // Preserve original date
                };
            } else {
                // Create new
                gameData.id = currentHash + "_" + new Date().getTime();
                library.push(gameData);
            }

            localStorage.setItem(STORAGE_KEY, JSON.stringify(library));
            if (typeof renderGameList === 'function') renderGameList();
        }

        function loadGameFromLibrary(id) {
            const STORAGE_KEY = 'chess_coach_library';
            let library = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const savedGame = library.find(g => g.id === id);

            if (!savedGame) { alert("Game not found!"); return; }

            // 1. Load PGN
            try {
                game.load_pgn(savedGame.pgn);
                gameHistory = game.history({ verbose: true });
                game.reset();
                currentMoveIndex = -1;
                board.position(game.fen());
                board.orientation('white');
            } catch (e) {
                console.error("PGN Load Error", e);
                return;
            }

            // 2. Restore Analysis Data
            analysisData = savedGame.analysisData;
            geminiComments = savedGame.geminiComments || {};
            gameStats = savedGame.gameStats;

            // 3. Update UI
            stopInteractiveMode();
            updateUI();

            // 4. Update Header (INSTANTLY)
            if (gameStats) {
                updateMatchHeader(gameStats.white, gameStats.black, gameStats.complexity);
            }

            // 5. Populate Coach Box with Summary immediately
            document.getElementById('gameStatus').innerText = "Analysis Loaded.";
            document.getElementById('openingName').innerText = savedGame.opening || "";

            // Force coach box update to show summary
            currentMoveIndex = -1;
            updateCoachBox();

            // Close Sidebar
            const sidebar = document.getElementById('librarySidebar');
            if(sidebar && !sidebar.classList.contains('-translate-x-full')) toggleSidebar();
        }

        function updateMatchHeader(white, black, complexity) {
            const header = document.getElementById('matchHeader');
            header.classList.remove('hidden');

            // White
            document.getElementById('whiteAccuracy').innerText = white.accuracy + '%';
            document.getElementById('whiteArchetype').innerText = white.archetype.label;
            document.getElementById('whiteArchIcon').className = `fa-solid ${white.archetype.icon} text-2xl text-indigo-500 mb-1`;

            // Black
            document.getElementById('blackAccuracy').innerText = black.accuracy + '%';
            document.getElementById('blackArchetype').innerText = black.archetype.label;
            document.getElementById('blackArchIcon').className = `fa-solid ${black.archetype.icon} text-2xl text-indigo-500 mb-1`;

            // Complexity
            // Map 0-5 to 0-100% width
            const percentage = Math.min(100, (parseFloat(complexity) / 5.0) * 100);
            document.getElementById('complexityFill').style.width = percentage + '%';
            document.getElementById('complexityScore').innerText = complexity;
        }

        function getDetailedMoveStats(gameObj, moveObj, oldFen) {
            const getMat = (fen) => {
                let s = 0;
                const vals = {p:1, n:3, b:3, r:5, q:9, k:0};
                fen.split(' ')[0].split('').forEach(c => {
                    if(vals[c.toLowerCase()]) s += (c === c.toUpperCase() ? vals[c.toLowerCase()] : -vals[c.toLowerCase()]);
                });
                return s; // Positive = White ahead, Negative = Black ahead
            };
            
            const rawMat = getMat(gameObj.fen());
            
            const getCenter = (gameInst) => {
                const report = HeatMap.analyze(gameInst);
                const score = report.strategy.centerControl;
                return (moveObj.color === 'w') ? score : -score;
            };
            return {
                rawMaterial: rawMat,
                material: (moveObj.color === 'w') ? rawMat : -rawMat,
                center: getCenter(gameObj),
                captured: (moveObj.captured || null),
                isCheck: gameObj.in_check()
            };
        }

        function parseEvalToNumber(evalStr) {
            if (typeof evalStr === 'string' && evalStr.startsWith('M')) {
                return parseInt(evalStr.replace('M', '')) > 0 ? 10 : -10;
            }
            return parseFloat(evalStr);
        }

        function estimateWDL(ev) {
            const w = 500 + (500 * (2 / (1 + Math.exp(-0.004 * (ev * 100))) - 1));
            return [Math.round(w), 0, Math.round(1000 - w)];
        }

        function getPieceCount(fen) { return fen.split(' ')[0].replace(/[^a-zA-Z]/g,'').length; }

        function getMaterialScore(fen) {
            let s = 0;
            const vals = {p:1, n:3, b:3, r:5, q:9, k:0};
            fen.split(' ')[0].split('').forEach(c => {
                if(vals[c.toLowerCase()]) {
                    s += (c === c.toUpperCase() ? vals[c.toLowerCase()] : -vals[c.toLowerCase()]);
                }
            });
            return s;
        }

        async function fetchBookData(fen) {
            try { 
                const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`);
                if(res.ok) return await res.json();
            } catch(e){ return null; }
            return null;
        }

        async function fetchTablebase(fen) {
            try { return (await (await fetch(`https://tablebase.lichess.ovh/standard?fen=${fen}`)).json()).category; } catch(e){return null;}
        }

        function isSquareProtected(gameObj, targetSq) {
            const turn = gameObj.turn();
            const movedColor = turn === 'w' ? 'b' : 'w';

            // Clone game to avoid mutating the actual game state
            const temp = new Chess(gameObj.fen());

            // Remove the piece at target and replace with an OPPONENT piece
            // This allows us to check if we can 'capture' it (i.e., defend it)
            temp.remove(targetSq);
            temp.put({ type: 'p', color: turn }, targetSq);

            // Force turn to be the mover's turn so we can generate their moves
            const tokens = temp.fen().split(' ');
            tokens[1] = movedColor;
            tokens[3] = '-';
            const newFen = tokens.join(' ');

            const temp2 = new Chess(newFen);
            const moves = temp2.moves({verbose: true});

            // Check if any move captures on targetSq
            return moves.some(m => m.to === targetSq);
        }

        function detectTactics(g, m) {
            if (m.flags.includes('c') || m.flags.includes('e')) return "Capture";
            if (m.san.includes('+')) return "Check";
            if (m.flags.includes('p')) return "Promotion";
            return null;
        }

        /* STRATEGIC ENGINE (Diamond V8) */
        const HeatMap = {
            val: { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 },

            // Main Entry Point
            analyze: function(chess) {
                let report = {
                    exchange: {},
                    strategy: this.getStrategicSnapshot(chess),
                    pawns: this.getPawnStructure(chess)
                };

                // Calculate 'True Control' (Net Exchange Value)
                const files = ['a','b','c','d','e','f','g','h'];
                for(let r=0; r<8; r++){
                    for(let c=0; c<8; c++){
                        const sq = files[c] + (8-r);
                        // Only analyze squares where something is actually happening
                        const exchange = this.getExchangeAnalysis(chess, sq);
                        if (exchange.attackers.length > 0 || exchange.defenders.length > 0) {
                            report.exchange[sq] = exchange;
                        }
                    }
                }
                return report;
            },

            // 1. STRUCTURE: Detect Doubled Pawns
            getPawnStructure: function(chess) {
                const board = chess.board();
                let structure = { w: { dbl:0 }, b: { dbl:0 } };

                for(let c=0; c<8; c++) {
                    let wPawns = 0, bPawns = 0;
                    for(let r=0; r<8; r++) {
                        const p = board[r][c];
                        if(p && p.type === 'p') {
                            if(p.color === 'w') wPawns++; else bPawns++;
                        }
                    }
                    if(wPawns > 1) structure.w.dbl++;
                    if(bPawns > 1) structure.b.dbl++;
                }
                return structure;
            },

            // 2. STRATEGY: Material & Center Control
            getStrategicSnapshot: function(chess) {
                const board = chess.board();
                let matW = 0, matB = 0;
                let centerW = 0, centerB = 0;
                const centerSquares = [[3,3], [3,4], [4,3], [4,4]]; // d5, e5, d4, e4

                for(let r=0; r<8; r++){
                    for(let c=0; c<8; c++){
                        const p = board[r][c];
                        if(p) {
                            const v = this.val[p.type] || 0;
                            if(p.color === 'w') matW += v; else matB += v;
                        }
                    }
                }

                // Check who physically occupies the center
                centerSquares.forEach(coord => {
                    const p = board[coord[0]][coord[1]];
                    if (p) { if (p.color === 'w') centerW++; else centerB++; }
                });

                const totalMat = matW + matB;
                let phase = "Middlegame";
                if (totalMat < 20) phase = "Endgame";
                if (totalMat > 60) phase = "Opening";

                return {
                    materialBalance: matW - matB,
                    centerControl: centerW - centerB,
                    phase: phase
                };
            },

            // 3. TACTICS: Exchange Calculator
            getExchangeAnalysis: function(chess, square) {
                const turn = chess.turn();
                const opp = turn === 'w' ? 'b' : 'w';

                // We use a temp board to see who can move to the square
                const temp = new Chess(chess.fen());
                const attackers = this.getAttackers(temp, square, opp);
                const defenders = this.getAttackers(temp, square, turn);

                const atkVal = attackers.reduce((acc, p) => acc + (this.val[p.toLowerCase()] || 0), 0);
                const defVal = defenders.reduce((acc, p) => acc + (this.val[p.toLowerCase()] || 0), 0);

                let status = "Safe";
                // If they have more attackers, or equal attackers but ours are more valuable (bad trade)
                if (attackers.length > defenders.length) status = "Lost";
                else if (attackers.length > 0 && atkVal < defVal) status = "Contested";

                return {
                    attackers: attackers, defenders: defenders,
                    netValue: defVal - atkVal,
                    status: status
                };
            },

            getAttackers: function(chess, sq, color) {
                // Simple trick: remove the piece at sq, put a pawn of the OPPOSITE color there,
                // then see if 'color' can capture it.
                // (Note: This is a simplified heuristic for speed)
                const moves = chess.moves({ verbose: true });
                // Filter for moves that land on 'sq' and are by 'color'
                // In a real implementation, we might need more robust checking,
                // but this fits the existing app structure.
                return moves.filter(m => m.to === sq && m.color === color).map(m => m.piece.toUpperCase());
            }
        };
        
        function uciToSan(fen, pv) {
            if(!pv) return "";
            const t = new Chess(fen);
            let s = "";
            let mvs = pv.split(' ');
            for(let m of mvs) {
                let mo = t.move({from:m.substring(0,2), to:m.substring(2,4), promotion: m.length>4?m.substring(4,5):undefined});
                if(mo) s += mo.san + " "; else break;
            }
            return s;
        }

        // --- 10. GEMINI API (UPDATED PROMPT with Game Summary Context) ---
        async function getGeminiCommentary(key, focus, opening, gameSummary) {
            let log = gameSummary; // Start the log with the overall game summary
            
            // 1. Compress Opening Book moves
            let bookLimit = 0;
            for(let i=0; i<analysisData.length; i++) {
                if(analysisData[i].classification !== 'Book') break;
                bookLimit = i;
            }
            
            if (bookLimit > 2) {
                log += `[OPENING SUMMARY]: The game started with ${opening}. Moves 1-${bookLimit+1} followed standard theory.\n\n`;
            }

            // 2. Build Move Log
            analysisData.forEach((d, i) => {
                // Skip individual book moves if we summarized them
                if (i <= bookLimit && d.classification === 'Book') return;

                const isUserTurn = (focus === 'both' || focus === d.color);
                if (!isUserTurn) return;

                const isError = ["Mistake", "Blunder", "Miss", "Inaccuracy"].includes(d.classification);
                const isInteresting = ["Best", "Great", "Brilliant", "Excellent"].includes(d.classification);
                const isMate = !!d.isMate;
                
                if (isError || d.tactic || isMate || (isInteresting && i % 4 === 0)) {
                    
                    const moveInfo = `Move ${i + 1} (${d.color}): ${d.san}`;
                    
                    // Interpret Score for Gemini
                    let scoreNum = parseEvalToNumber(d.eval);
                    let stateLabel = "Equal";
                    if (scoreNum > 1.0) stateLabel = "White Slight Edge";
                    if (scoreNum > 3.0) stateLabel = "White Winning";
                    if (scoreNum < -1.0) stateLabel = "Black Slight Edge";
                    if (scoreNum < -3.0) stateLabel = "Black Winning";
                    if (d.eval.toString().includes("M")) stateLabel = "Forced Mate Detected";

                    // Calculate Stability Shift
                    let stabBefore = 0;
                    if (d.stability) stabBefore = d.stability.filter(s => s === 'green').length;

                    // Post-move stability (the pressure inflicted on opponent)
                    let stabAfter = 0;
                    if (d.postMoveStability) stabAfter = d.postMoveStability.filter(s => s === 'green').length;

                    const stats = `[Eval: ${d.eval} (${stateLabel})] [Class: ${d.classification}] [My Stability: ${stabBefore}/10] [Opponent Stability After: ${stabAfter}/10]`;
                    
                    let comparison = "";
                    if (d.stats && d.stats.best) {
                        const u = d.stats.user;
                        const b = d.stats.best;
                        comparison = `Stats: User(Mat:${u.material}, Center:${u.center}) vs Best(Mat:${b.material}, Center:${b.center})`;
                    }

                    // --- NEW CONTEXT INJECTION ---
                    if (d.materialStatus === "HUNG_PIECE") {
                        comparison += ` [TACTICAL ERROR: Piece was left completely undefended]`;
                    } else if (d.materialStatus === "BAD_TRADE") {
                        comparison += ` [EXCHANGE ERROR: Piece was defended but the trade lost material value]`;
                    } else if (d.materialStatus === "TRADED_AWAY_ADVANTAGE") {
                        comparison += ` [STRATEGIC ERROR: Material is equal but the trade simplified the game for the opponent]`;
                    } else if (d.materialStatus === "POSITIONAL_BLUNDER") {
                        comparison += ` [POSITIONAL ERROR: No material lost, but King safety or piece activity is collapsing]`;
                    } else if (d.materialStatus === "MISSED_WIN") {
                        comparison += ` [OPPORTUNITY: You missed a chance to win material or a free capture]`;
                    }

                    let tacticInfo = d.tactic ? `[TACTIC: ${d.tactic}]` : '';
                    if (isMate) tacticInfo = "[GAME OVER: CHECKMATE]"; 
                    
                    // Critical Moment Tag
                    if (d.isCritical && d.classification === 'Best') {
                        tacticInfo += " [HERO MOMENT: The user found the ONLY move that survives/wins!]";
                    }

                    const bestLineInfo = isError ? `\n   -> Engine Best: ${d.bestMoveSan}\n   -> Engine Line: ${d.pvSan}` : '';
                    
                    log += `${moveInfo} ${stats} ${tacticInfo} ${comparison}${bestLineInfo}\nFEN: ${d.fenBefore}\n\n`;
                }
            });

            if (log.length < 50) log = gameSummary + "\nGame was too short for detailed move analysis.";

           const prompt = `
You are a Grandmaster Chess Coach.

**TASK:**
Provide brief, insightful, and natural commentary on the provided game log.

// --- CRITICAL VOCABULARY RULES (STRICT) ---
1. **BANNED WORDS:** Do NOT use the following classification labels in your text:
   - "Excellent", "Best", "Inaccuracy", "Mistake", "Blunder", "Book", "Hero Moment".
   - *INSTEAD:* Use synonyms.
     - For "Excellent/Best": Use "Strong," "Dominant," "Precise," "Crushing," "Essential."
     - For "Inaccuracy/Mistake": Use "Slip," "Oversight," "Dubious," "Loose," "Passive."
     - For "Blunder": Use "Disaster," "Critical error," "Throws the game," "Collapse."
     - For "Hero Moment": Use "The only path," "A brilliant resource," "Keeping hope alive."

2. **NO ROBOT QUOTING:** Never put single words in apostrophes (e.g., never say "This 'Good' move"). Just write naturally.
// ------------------------------------------

**TONE ADJUSTMENT:**
The [GAME SUMMARY] contains the overall ACPL and Complexity. Use this to set the tone, but ALWAYS infuse "Grandmaster" traits. Be opinionated. Use sophisticated chess concepts like 'over-extending', 'intermediate moves (zwischenzug)', 'piece activity', or 'prophylaxis' to explain technical points.

1. **Master-Level Precision** -> Adopt persona: "The Encouraging Mentor".
   - Enthusiastic and supportive, but strategic.
   - Frame errors as minor technical oversights preventing perfection.
   - Congratulate them on sharp play.

2. **Wild Tactical Chaos** -> Adopt persona: "The Safety Officer".
   - Hyper-aware of defense and King Safety.
   - Explain WHY a move avoided a trap using specific tactical terms.
   - Use phrases like "in this minefield" or "navigated the complications".

3. **Erratic and Risky** -> Adopt persona: "The Consistency Coach".
   - Firm but patient.
   - For severe errors, emphasize calculation habits.
   - For strong moves, highlight the value of simple, steady play and solid structure.

**GENERAL GUIDELINES:**
- **Opening:** Be educational. Mention the opening goals.
- **Endgame:** If the game is "Winning" or "Lost" (Eval > 3 or < -3), stop nitpicking small inaccuracies.

**STABILITY CONTEXT (PRESSURE SHIFT):**
Each move includes [My Stability: X/10] and [Opponent Stability After: Y/10].

**Use this to narrate the flow of pressure:**
1. **The "Minefield" Move (High Impact):**
   - If [My Stability] was High/Medium, but [Opponent Stability After] is Low (0-2).
   - *Narrative:* "You threw them into a minefield!" "Brilliant squeezeBlack has nowhere to run."

2. **The "Escape" (Survival):**
   - If [My Stability] was Low (0-2) and you found a top move.
   - *Narrative:* "You were walking a tightrope, but you found the only path to stay alive."

3. **The "Pressure Release":**
   - If you played a weak move and [Opponent Stability After] jumps up.
   - *Narrative:* "You let the pressure off. Now they have easy choices."

**Archetype Focus:** "The Magician" loves creating Low Stability for the opponent (Chaos). "The Solid Pro" hates Low Stability for themselves.

**OUTPUT RULES:**
1. **Context, Not Labels:** Do NOT repeat the technical tags (like 'win material') verbatim. Use them as the *reason* for your advice.
2. **Varied Vocabulary:** Avoid repetitive phrases. If the tag is [OPPORTUNITY], vary it: 'You left a gift on the table,' 'Tactical oversight regarding the knight,' etc.
3. **The 'Why':** When you see [POSITIONAL ERROR], look at the FEN. Explain the *consequences* (e.g., "Your pieces are tripping over each other").
4. **Accuracy:** Trust the [Eval] tag provided.

**JSON Format:**
{
    "12": {
        "analysis": "This push over-extends your pawn chain. A better approach was Nf3, keeping the structure solid.",
        "pv_explanation": ["Nf3 controls the center without creating weaknesses"]
    }
}

**Game Log:**
${log}
`;
            try {
                const res = await fetch(MODEL_ENDPOINT+`?key=${key}`, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                const rawText = d.candidates[0].content.parts[0].text;

                // Robust JSON Extraction
                const jsonStart = rawText.indexOf('{');
                const jsonEnd = rawText.lastIndexOf('}');

                if (jsonStart !== -1 && jsonEnd !== -1) {
                    const jsonStr = rawText.substring(jsonStart, jsonEnd + 1);
                    geminiComments = JSON.parse(jsonStr);
                } else {
                    throw new Error("No JSON found in response");
                }
            } catch(e) {
                console.error("Gemini API Error:", e);
                geminiComments = {};
            }
        }

        // --- 11. CHAT ---
        async function sendChatMessage() {
            const txt = document.getElementById('chatInput').value;
            const key = localStorage.getItem('gemini_api_key');
            if(!key || !txt) return;
            const hist = document.getElementById('chatHistory');
            hist.innerHTML += `<div class="bg-indigo-50 p-2 rounded mb-2 text-right"><b>You:</b> ${txt}</div>`;
            document.getElementById('chatInput').value = "";
            hist.scrollTop = hist.scrollHeight;
            try {
                const res = await fetch(MODEL_ENDPOINT+`?key=${key}`, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: `Context: PGN=${game.pgn()}, FEN=${game.fen()}. User: ${txt}` }] }] })
                });
                const d = await res.json();
                hist.innerHTML += `<div class="text-left mb-2 text-gray-700"><b>Coach:</b> ${marked.parse(d.candidates[0].content.parts[0].text)}</div>`;
                hist.scrollTop = hist.scrollHeight;
            } catch(e) { hist.innerHTML += `<div class="text-red-500">Error.</div>`; }
        }
        function handleChatEnter(e) { if(e.key === 'Enter') sendChatMessage(); }

        function loadSettings() {
            const key = localStorage.getItem('gemini_api_key');
            const user = localStorage.getItem('chess_username');
            if(key) document.getElementById('apiKeyInput').value = key;
            if(user) document.getElementById('usernameInput').value = user;
        }

        function saveSettings() {
            localStorage.setItem('gemini_api_key', document.getElementById('apiKeyInput').value);
            localStorage.setItem('chess_username', document.getElementById('usernameInput').value.trim());
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function openSettings() {
            loadSettings();
            document.getElementById('settingsModal').classList.remove('hidden');
        }

        function cancelAnalysis() { isAnalyzing = false; document.getElementById('analysisOverlay').classList.add('hidden'); document.getElementById('analyzeBtn').disabled = false; }
        
        function copyAnalysisToClipboard() {
            if (!analysisData || analysisData.length === 0) {
                alert("No analysis available to copy. Run the Review first.");
                return;
            }

            let text = "Game Analysis Report\n--------------------\n\n";

            analysisData.forEach((move, index) => {
                const moveNum = Math.floor(index / 2) + 1;
                const turn = move.color === 'w' ? "White" : "Black";
                const dot = move.color === 'w' ? "." : "...";

                let evalText = move.eval;
                if (typeof evalText === 'string' && !evalText.startsWith('M') && !evalText.startsWith('-') && parseFloat(evalText) > 0) {
                    evalText = '+' + evalText;
                }

                let winChance = "N/A";
                if (move.wdl) {
                    winChance = (move.wdl[0] / 10).toFixed(1) + "%";
                }

                let comment = "";
                const gData = geminiComments[index + 1];
                if (gData) {
                    if (typeof gData === 'string') comment = gData;
                    else if (gData.analysis) comment = gData.analysis;
                }

                text += `${moveNum}${dot} ${move.san} (${turn})\n`;
                text += `   Eval: ${evalText} | Win Chance: ${winChance} | Class: ${move.classification}\n`;
                if (comment) {
                    text += `   Coach: ${comment}\n`;
                }
                text += "\n";
            });

            navigator.clipboard.writeText(text).then(() => {
                alert("Analysis copied to clipboard!");
            }).catch(err => {
                console.error("Copy failed", err);
                alert("Failed to copy analysis.");
            });
        }

    </script>
</body>
</html>
