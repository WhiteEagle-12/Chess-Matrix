<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Chess Coach Pro (Fixed)</title>
    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { background-color: #f0f2f5; touch-action: manipulation; font-family: 'Segoe UI', system-ui, sans-serif; }
        
        .board-container {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 12px;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            position: relative; 
        }

        #board { 
            flex: 1; 
            min-width: 0; 
            width: 100%; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); 
            z-index: 1;
        }

        #arrowOverlay {
            position: absolute;
            top: 0;
            left: 36px; 
            width: calc(100% - 36px);
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .highlight-last { background-color: rgba(255, 255, 0, 0.4) !important; }

        /* Heatmap */
        .square-control-w-1 { box-shadow: inset 0 0 0 1000px rgba(74, 222, 128, 0.2); }
        .square-control-w-2 { box-shadow: inset 0 0 0 1000px rgba(34, 197, 94, 0.4); }
        .square-control-w-3 { box-shadow: inset 0 0 0 1000px rgba(21, 128, 61, 0.6); }
        .square-control-b-1 { box-shadow: inset 0 0 0 1000px rgba(248, 113, 113, 0.2); }
        .square-control-b-2 { box-shadow: inset 0 0 0 1000px rgba(239, 68, 68, 0.4); }
        .square-control-b-3 { box-shadow: inset 0 0 0 1000px rgba(185, 28, 28, 0.6); }

        /* Eval Bar */
        .eval-bar-container {
            flex: 0 0 24px;
            width: 24px;
            background-color: #374151;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column-reverse;
            z-index: 5;
        }
        .eval-bar-fill {
            width: 100%;
            background-color: #ffffff;
            height: 50%;
            transition: height 0.5s ease-out;
            border-top: 1px solid #9ca3af;
        }
        .eval-score-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            color: #999;
            z-index: 10;
            top: 4px;
            pointer-events: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        .eval-score-text.bottom { top: auto; bottom: 4px; color: #ccc; }
        
        .piece-417db { background-size: 100%; }

        /* Coach Box */
        .coach-box {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-left: 5px solid #cbd5e1;
            transition: all 0.3s ease;
            position: relative;
            min-height: 160px;
        }
        .coach-box.pv-active { border-left-color: #6366f1; background: #eef2ff; }
        .coach-box.practice-active { border-left-color: #f59e0b; background: #fffbeb; }

        .coach-box.best { border-left-color: #22c55e; background: #f0fdf4; }
        .coach-box.excellent { border-left-color: #16a34a; background: #f0fdf4; }
        .coach-box.good { border-left-color: #84cc16; }
        .coach-box.inaccuracy { border-left-color: #facc15; background: #fefce8; } 
        .coach-box.mistake { border-left-color: #f97316; background: #fff7ed; } 
        .coach-box.miss { border-left-color: #f43f5e; background: #fff1f2; } 
        .coach-box.blunder { border-left-color: #dc2626; background: #fef2f2; } 
        .coach-box.book { border-left-color: #a855f7; }

        .classification-badge {
            font-size: 0.7rem; text-transform: uppercase; font-weight: 800; letter-spacing: 0.05em;
            padding: 2px 6px; border-radius: 4px; color: white; display: inline-block; margin-bottom: 4px;
        }
        .bg-best { background-color: #22c55e; }
        .bg-excellent { background-color: #16a34a; }
        .bg-good { background-color: #84cc16; }
        .bg-inaccuracy { background-color: #eab308; color: #fff; }
        .bg-mistake { background-color: #f97316; }
        .bg-miss { background-color: #f43f5e; }
        .bg-blunder { background-color: #dc2626; }
        .bg-book { background-color: #a855f7; }
        .bg-neutral { background-color: #94a3b8; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .pv-controls-container, .practice-controls-container { display: none; flex-direction: column; height: 100%; justify-content: space-between; }
        .pv-active .pv-controls-container { display: flex; }
        .pv-active .normal-feedback { display: none; }
        .practice-active .practice-controls-container { display: flex; }
        .practice-active .normal-feedback { display: none; }
        
        .board-pv-highlight { box-shadow: 0 0 0 4px #6366f1 !important; }
        .board-practice-mode { box-shadow: 0 0 0 4px #f59e0b !important; }

        .practice-success { animation: pulseGreen 1s; }
        .practice-fail { animation: shake 0.5s; }

        @keyframes pulseGreen { 0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); } 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body class="pb-12">

    <nav class="bg-indigo-700 text-white p-3 shadow-md sticky top-0 z-50">
        <div class="max-w-2xl mx-auto flex justify-between items-center">
            <h1 class="font-bold text-lg"><i class="fa-solid fa-chess"></i> Chess Coach Pro</h1>
            <div class="flex gap-2">
                <button onclick="toggleHeatmap()" class="text-white hover:text-indigo-200" title="Toggle Threat Map">
                    <i class="fa-solid fa-eye"></i>
                </button>
                <button onclick="flipBoard()" class="text-white hover:text-indigo-200" title="Flip Board">
                    <i class="fa-solid fa-retweet"></i>
                </button>
                <button onclick="openSettings()" class="text-white hover:text-indigo-200">
                    <i class="fa-solid fa-gear"></i>
                </button>
            </div>
        </div>
    </nav>

    <div class="max-w-2xl mx-auto p-4 flex flex-col gap-4">

        <div class="flex justify-between items-center bg-white p-3 rounded-lg shadow-sm">
            <div class="flex items-center gap-3">
                <div id="turnIndicator" class="w-3 h-3 rounded-full bg-white border-2 border-black"></div>
                <div class="flex flex-col">
                    <span id="gameStatus" class="text-xs font-semibold text-gray-700">Load a game to start</span>
                    <span id="openingName" class="text-[10px] text-gray-500 font-mono truncate max-w-[150px]"></span>
                </div>
            </div>
            <div class="flex flex-col items-end">
                <div id="evalText" class="font-mono text-sm bg-gray-800 text-yellow-400 px-2 py-1 rounded">0.00</div>
                <div id="wdlText" class="text-[10px] text-gray-400 font-bold mt-1 hidden">Win: 50%</div>
            </div>
        </div>

        <div class="relative board-container">
            <div class="eval-bar-container">
                <div class="eval-score-text" id="evalBarTextTop"></div>
                <div id="visualEvalBar" class="eval-bar-fill" style="height: 50%;"></div>
                <div class="eval-score-text bottom" id="evalBarTextBottom"></div>
            </div>

            <div id="board" class="relative transition-shadow duration-300"></div>
            
            <svg id="arrowOverlay"></svg>

            <div id="analysisOverlay" class="absolute inset-0 bg-white/95 z-20 hidden flex flex-col items-center justify-center rounded">
                <button onclick="cancelAnalysis()" class="absolute top-2 right-2 text-gray-400 hover:text-red-500 p-2">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
                <div id="statusTitle" class="text-indigo-600 font-bold mb-4 text-lg animate-pulse">Analyzing with Stockfish...</div>
                <div class="w-64 h-3 bg-gray-200 rounded-full overflow-hidden mb-2">
                    <div id="progressBar" class="h-full bg-indigo-500 transition-all duration-300" style="width: 0%"></div>
                </div>
                <div id="progressText" class="text-xs text-gray-500 font-mono">Initializing...</div>
                <div id="geminiStatus" class="text-xs text-purple-600 mt-2 font-bold hidden">Coach is generating insights...</div>
            </div>
            
            <div id="pvModeBadge" class="absolute top-2 right-2 bg-indigo-600 text-white text-xs px-3 py-1 rounded-full shadow-lg hidden pointer-events-none z-10 font-bold animate-bounce">
                Best Line Explorer
            </div>
            <div id="practiceModeBadge" class="absolute top-2 right-2 bg-amber-500 text-white text-xs px-3 py-1 rounded-full shadow-lg hidden pointer-events-none z-10 font-bold animate-pulse">
                Practice Mode
            </div>
        </div>

        <div class="flex flex-col gap-2">
            <div class="grid grid-cols-5 gap-2" id="mainNavButtons">
                <button onclick="goToStart()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angles-left"></i></button>
                <button onclick="prevMove()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angle-left"></i></button>
                
                <div class="relative group">
                    <button onclick="startAnalysis()" id="analyzeBtn" class="w-full h-full bg-indigo-600 text-white font-bold p-2 rounded shadow hover:bg-indigo-700 flex justify-center items-center gap-2">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> Review
                    </button>
                </div>

                <button onclick="nextMove()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angle-right"></i></button>
                <button onclick="goToEnd()" class="bg-white p-2 rounded shadow text-gray-600 hover:bg-gray-50"><i class="fa-solid fa-angles-right"></i></button>
            </div>
            
            <div class="flex justify-end items-center gap-2 text-xs text-gray-600" id="analysisOptions">
                <button onclick="copyAnalysisToClipboard()" class="bg-white border border-gray-300 px-2 py-1 rounded shadow-sm hover:bg-gray-50 text-indigo-700 font-semibold mr-auto">
                    <i class="fa-solid fa-copy"></i> Copy Analysis
                </button>
                <span class="font-bold">Coach Focus:</span>
                <select id="analysisFocus" class="border rounded p-1 bg-white">
                    <option value="both">Both Sides</option>
                    <option value="w">White (My Moves)</option>
                    <option value="b">Black (My Moves)</option>
                </select>
            </div>
        </div>

        <div id="coachBox" class="coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center">
            
            <div class="normal-feedback">
                <div id="feedbackPlaceholder" class="text-center text-gray-400 text-sm">
                    <i class="fa-solid fa-comment-dots text-2xl mb-2"></i><br>
                    Press "Review" to get AI coaching.
                </div>
                
                <div id="feedbackContent" class="hidden">
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <span id="moveClassBadge" class="classification-badge bg-neutral">Neutral</span>
                            <span id="tacticsBadge" class="hidden text-[10px] bg-red-100 text-red-600 px-1 rounded font-bold border border-red-200">TACTIC</span>
                        </div>
                        <span id="moveNumber" class="text-xs text-gray-400 font-mono">1. e4</span>
                    </div>
                    <div id="coachText" class="text-sm text-gray-800 leading-relaxed font-medium"></div>
                    
                    <div id="bestMoveSuggestion" class="hidden mt-3 pt-3 border-t border-gray-200/50 flex flex-col gap-2">
                        <div class="text-xs text-gray-500">
                             Best was: <b id="bestMoveText"></b>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                             <button onclick="startPvReview()" class="bg-indigo-50 text-indigo-700 px-3 py-2 rounded text-xs font-bold hover:bg-indigo-100 transition-colors flex items-center justify-center gap-2 border border-indigo-200">
                                <i class="fa-solid fa-chess-board"></i> View Line
                            </button>
                            <button onclick="startPracticeMode()" class="bg-amber-50 text-amber-700 px-3 py-2 rounded text-xs font-bold hover:bg-amber-100 transition-colors flex items-center justify-center gap-2 border border-amber-200">
                                <i class="fa-solid fa-rotate-left"></i> Retry Move
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pv-controls-container">
                <div class="flex justify-between items-center mb-2 border-b border-indigo-200 pb-2">
                    <span class="text-xs font-bold text-indigo-700 uppercase tracking-wider">Engine Line</span>
                    <button onclick="stopInteractiveMode()" class="text-xs text-gray-400 hover:text-red-500 font-bold px-2">
                        <i class="fa-solid fa-times"></i> EXIT
                    </button>
                </div>
                <div id="pvCommentText" class="text-sm text-gray-800 font-medium mb-3 min-h-[60px]">Loading...</div>
                <div class="flex items-center justify-between bg-white rounded-lg border border-gray-200 p-1">
                    <button onclick="prevPvMove()" class="p-2 text-gray-600 hover:text-indigo-600 hover:bg-gray-50 rounded w-10"><i class="fa-solid fa-chevron-left"></i></button>
                    <div class="text-xs font-mono font-bold text-gray-700" id="pvMoveIndicator">Start</div>
                    <button onclick="nextPvMove()" class="p-2 text-gray-600 hover:text-indigo-600 hover:bg-gray-50 rounded w-10"><i class="fa-solid fa-chevron-right"></i></button>
                </div>
            </div>

            <div class="practice-controls-container">
                <div class="flex justify-between items-center mb-2 border-b border-amber-200 pb-2">
                    <span class="text-xs font-bold text-amber-700 uppercase tracking-wider">Find the Move</span>
                    <button onclick="stopInteractiveMode()" class="text-xs text-gray-400 hover:text-red-500 font-bold px-2">
                        <i class="fa-solid fa-times"></i> GAVE UP
                    </button>
                </div>
                <div id="practiceFeedbackText" class="text-sm text-gray-800 font-medium mb-3 min-h-[40px] flex items-center justify-center text-center">
                    Drag the pieces to find the best move.
                </div>
            </div>

        </div>

        <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden mt-4">
            <div class="bg-gray-50 px-4 py-2 border-b text-xs font-bold text-gray-500 uppercase">Ask the Coach</div>
            <div id="chatHistory" class="p-4 h-40 overflow-y-auto text-sm space-y-2">
                <div class="text-gray-400 italic text-center text-xs mt-10">Ask specific questions about the game here...</div>
            </div>
            <div class="p-2 border-t flex gap-2 bg-gray-50">
                <input type="text" id="chatInput" placeholder="Why was that move bad?" class="flex-1 border rounded px-3 py-1 text-sm focus:outline-none focus:border-indigo-500" onkeypress="handleChatEnter(event)">
                <button onclick="sendChatMessage()" class="bg-indigo-600 text-white px-3 rounded hover:bg-indigo-700"><i class="fa-solid fa-paper-plane"></i></button>
            </div>
        </div>

    </div>

    <div id="settingsModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-sm">
            <h2 class="text-lg font-bold mb-4">Settings</h2>
            <div class="mb-4">
                <label class="block text-xs font-bold text-gray-600 mb-1">Gemini API Key</label>
                <input type="password" id="apiKeyInput" placeholder="Paste key here..." class="w-full border p-2 rounded text-sm">
                <p class="text-xs text-gray-400 mt-1">Key is saved in browser storage.</p>
            </div>
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('settingsModal').classList.add('hidden')" class="px-4 py-2 text-gray-600 text-sm">Close</button>
                <button id="saveKeyBtn" onclick="saveSettings()" class="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">Save Key</button>
            </div>
        </div>
    </div>

    <div id="pgnModal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 max-w-md">
            <h2 class="text-lg font-bold mb-2">Load Game</h2>
            <textarea id="pgnInput" class="w-full border p-2 h-40 font-mono text-xs rounded mb-4" placeholder="Paste PGN here..."></textarea>
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('pgnModal').classList.add('hidden')" class="px-4 py-2 text-gray-600 text-sm">Cancel</button>
                <button id="loadPgnBtn" onclick="loadPGN()" class="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">Load Game</button>
            </div>
        </div>
    </div>
    
    <button onclick="document.getElementById('pgnModal').classList.remove('hidden')" class="fixed bottom-6 right-6 bg-indigo-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center hover:bg-indigo-700 z-40 transition-transform hover:scale-110">
        <i class="fa-solid fa-upload text-xl"></i>
    </button>

    <script>
        // --- CONSTANTS ---
        const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
        const MODEL_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent';

        // --- STATE ---
        let game = new Chess();
        let board = null;
        let stockfish = null;
        let gameHistory = []; 
        let currentMoveIndex = -1; 
        let analysisData = []; 
        let geminiComments = {}; 
        let gameStats = null;
        let isAnalyzing = false;
        let isHeatmapActive = false;
        
        let interactiveState = {
            mode: 'none', 
            pvMoves: [], 
            pvComments: [],
            pvIndex: -1,
            practiceTarget: null, 
            tempGame: null 
        };

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', () => {
            initBoard();
            initStockfish();
            loadSettings();
            if (!localStorage.getItem('gemini_api_key')) openSettings();
            setTimeout(() => { if(board) board.resize(); }, 300);
        });

        // --- 1. BOARD & PIECES ---
        function pieceTheme(piece) {
            return 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/' + piece.toLowerCase() + '.png';
        }

        function initBoard() {
            board = Chessboard('board', {
                position: 'start',
                draggable: false, 
                pieceTheme: pieceTheme,
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });
            window.addEventListener('resize', () => {
                board.resize();
                updateUI(); 
            });
        }
        
        function flipBoard() {
            if(board) board.flip();
            updateUI();
        }

        function toggleHeatmap() {
            isHeatmapActive = !isHeatmapActive;
            updateUI();
        }

        // --- 2. STOCKFISH ENGINE ---
        function initStockfish() {
            try {
                const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
                stockfish = new Worker(URL.createObjectURL(blob));
                stockfish.postMessage('uci');
                stockfish.postMessage('setoption name UCI_ShowWDL value true');
                stockfish.postMessage('setoption name MultiPV value 2');
            } catch (e) {
                console.error("Stockfish init failed:", e);
            }
        }

        // --- 3. GAME LOADING ---
        function loadPGN() {
            const btn = document.getElementById('loadPgnBtn');
            const originalText = btn.innerText;
            btn.innerText = "Loading...";

            setTimeout(() => {
                const pgn = document.getElementById('pgnInput').value.trim();
                if (!pgn) { btn.innerText = originalText; return; }

                try {
                    game.load_pgn(pgn) || game.load_pgn(pgn.replace(/\{.*?\}/g, '')) || game.load_pgn(pgn.replace(/\[.*?\]/g, ""));
                    
                    gameHistory = game.history({ verbose: true });
                    game.reset();
                    currentMoveIndex = -1;
                    board.position(game.fen());
                    board.orientation('white'); 
                    
                    analysisData = [];
                    geminiComments = {};
                    gameStats = null;
                    stopInteractiveMode();
                    
                    updateUI();
                    document.getElementById('pgnModal').classList.add('hidden');
                    document.getElementById('gameStatus').innerText = "Game Loaded.";
                    document.getElementById('feedbackPlaceholder').innerHTML = '<i class="fa-solid fa-wand-magic-sparkles text-2xl mb-2 text-indigo-500"></i><br>Game Loaded.<br>Click <b>Review</b> for AI Analysis.';
                    document.getElementById('pgnInput').value = ''; 
                    
                } catch (e) {
                    alert("Invalid PGN.");
                } finally {
                    btn.innerText = originalText;
                }
            }, 50);
        }

        // --- 4. NAVIGATION & VISUALS ---
        function updateUI() {
            if(interactiveState.mode !== 'none') return;
            
            board.position(game.fen());
            
            const turn = game.turn();
            document.getElementById('turnIndicator').className = `w-3 h-3 rounded-full border-2 border-black ${turn === 'w' ? 'bg-white' : 'bg-black'}`;

            if(currentMoveIndex >= 0 && analysisData[currentMoveIndex] && analysisData[currentMoveIndex].opening) {
                document.getElementById('openingName').innerText = analysisData[currentMoveIndex].opening;
            }

            clearHeatmap();
            clearHighlights();
            clearArrows();

            if(isHeatmapActive) renderHeatmap();
            highlightLastMove();
            drawBestMoveArrow();

            updateCoachBox();
            updateEvalBar();
        }

        function highlightLastMove() {
            if (currentMoveIndex < 0) return;
            const move = gameHistory[currentMoveIndex];
            $('#board .square-' + move.from).addClass('highlight-last');
            $('#board .square-' + move.to).addClass('highlight-last');
        }
        
        function clearHighlights() {
            $('#board .square-55d63').removeClass('highlight-last');
        }

        function clearArrows() {
            const svg = document.getElementById('arrowOverlay');
            while(svg.lastChild) svg.removeChild(svg.lastChild);
        }

        function drawBestMoveArrow() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];
            
            if (data.classification !== "Best" && data.bestMoveSan && data.bestMove && data.bestMove !== '-') {
                const bestFrom = data.bestMove.substring(0,2);
                const bestTo = data.bestMove.substring(2,4);
                drawArrow(bestFrom, bestTo, '#22c55e'); 
            }
        }

        function drawArrow(from, to, color) {
            const $board = $('#board');
            const boardWidth = $board.width();
            const sqSize = boardWidth / 8;
            const orientation = board.orientation();
            const cols = 'abcdefgh';
            const rows = '87654321';
            
            const getCoords = (sq) => {
                let c = cols.indexOf(sq[0]);
                let r = rows.indexOf(sq[1]);
                if (orientation === 'black') { c = 7 - c; r = 7 - r; }
                return { x: c * sqSize + sqSize/2, y: r * sqSize + sqSize/2 };
            }

            const start = getCoords(from);
            const end = getCoords(to);
            const svg = document.getElementById('arrowOverlay');
            const id = `arrow-${from}-${to}`;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', start.x);
            line.setAttribute('y1', start.y);
            line.setAttribute('x2', end.x);
            line.setAttribute('y2', end.y);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', sqSize * 0.15);
            line.setAttribute('opacity', '0.6');
            line.setAttribute('marker-end', `url(#head-${id})`);
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', `head-${id}`);
            marker.setAttribute('markerWidth', '4');
            marker.setAttribute('markerHeight', '4');
            marker.setAttribute('refX', '2');
            marker.setAttribute('refY', '2');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L4,2 L0,4 Z');
            path.setAttribute('fill', color);
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);
            svg.appendChild(line);
        }

        function nextMove() {
            if(interactiveState.mode !== 'none') return;
            if (currentMoveIndex < gameHistory.length - 1) {
                currentMoveIndex++;
                game.move(gameHistory[currentMoveIndex]);
                updateUI();
            }
        }

        function prevMove() {
            if(interactiveState.mode !== 'none') return;
            if (currentMoveIndex >= 0) {
                game.undo();
                currentMoveIndex--;
                updateUI();
            }
        }

        function goToStart() {
            if(interactiveState.mode !== 'none') return;
            game.reset();
            currentMoveIndex = -1;
            updateUI();
        }

        function goToEnd() {
            if(interactiveState.mode !== 'none') return;
            while (currentMoveIndex < gameHistory.length - 1) {
                currentMoveIndex++;
                game.move(gameHistory[currentMoveIndex]);
            }
            updateUI();
        }

        // --- 5. VISUALS (HEATMAP & EVAL) ---
        function updateEvalBar() {
            let evalVal = 0.00;
            let wdlText = "";
            const barFill = document.getElementById('visualEvalBar');
            const evalTextEl = document.getElementById('evalText');
            const wdlEl = document.getElementById('wdlText');
            
            if (currentMoveIndex >= 0 && analysisData[currentMoveIndex]) {
                const data = analysisData[currentMoveIndex];
                if (typeof data.eval === 'string' && data.eval.startsWith('M')) {
                    const mateIn = parseInt(data.eval.substring(1));
                    evalVal = mateIn > 0 ? 10 : -10; 
                    evalTextEl.innerText = `M${Math.abs(mateIn)}`;
                } else {
                    evalVal = parseFloat(data.eval);
                    evalTextEl.innerText = Math.abs(evalVal).toFixed(2);
                }
                if(data.wdl) {
                    const winP = (data.wdl[0] / 10).toFixed(0);
                    wdlText = `Win: ${winP}%`;
                    wdlEl.innerText = wdlText;
                    wdlEl.classList.remove('hidden');
                }
            } else {
                evalTextEl.innerText = "0.30";
                evalVal = 0.3;
                wdlEl.classList.add('hidden');
            }
            const percentage = 50 + (Math.max(-5, Math.min(5, evalVal)) * 10); 
            barFill.style.height = `${percentage}%`;
            evalTextEl.style.color = percentage > 90 ? '#333' : (percentage < 10 ? '#fff' : '#999');
        }

        function renderHeatmap() {
            if(currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const control = analysisData[currentMoveIndex].control;
            if(!control) return;
            const squares = ['a8','b8','c8','d8','e8','f8','g8','h8','a7','b7','c7','d7','e7','f7','g7','h7','a6','b6','c6','d6','e6','f6','g6','h6','a5','b5','c5','d5','e5','f5','g5','h5','a4','b4','c4','d4','e4','f4','g4','h4','a3','b3','c3','d3','e3','f3','g3','h3','a2','b2','c2','d2','e2','f2','g2','h2','a1','b1','c1','d1','e1','f1','g1','h1'];
            control.forEach((val, idx) => {
                if (val === 0) return;
                const sq = squares[idx];
                const $sq =  $('#board .square-' + sq);
                if (val > 0) { 
                    if (val >= 3) $sq.addClass('square-control-w-3');
                    else if (val === 2) $sq.addClass('square-control-w-2');
                    else $sq.addClass('square-control-w-1');
                } else { 
                    if (val <= -3) $sq.addClass('square-control-b-3');
                    else if (val === -2) $sq.addClass('square-control-b-2');
                    else $sq.addClass('square-control-b-1');
                }
            });
        }

        function clearHeatmap() {
            $('#board .square-55d63').removeClass(function(index, className) {
                return (className.match(/(^|\s)square-control-\S+/g) || []).join(' ');
            });
        }

        // --- 6. COACH BOX LOGIC ---
        function updateCoachBox() {
            if(interactiveState.mode !== 'none') return;
            const contentDiv = document.getElementById('feedbackContent');
            const placeholder = document.getElementById('feedbackPlaceholder');
            const box = document.getElementById('coachBox');
            const badge = document.getElementById('moveClassBadge');
            const tacticBadge = document.getElementById('tacticsBadge');
            const suggestionDiv = document.getElementById('bestMoveSuggestion');
            const bestMoveText = document.getElementById('bestMoveText');

            if (analysisData.length === 0 || currentMoveIndex === -1) {
                // Check if we have Game Stats to show (Post-Analysis State)
                if (gameStats) {
                    contentDiv.classList.add('hidden');
                    placeholder.classList.remove('hidden');
                    box.className = 'coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center border-l-8 border-indigo-500 bg-indigo-50';

                    // Render Game Summary Card
                    placeholder.innerHTML = `
                        <div class="text-left w-full">
                            <h3 class="font-bold text-indigo-800 border-b border-indigo-200 pb-1 mb-2">Game Summary</h3>
                            <div class="grid grid-cols-2 gap-4 text-sm mb-2">
                                <div>
                                    <div class="text-xs text-gray-500 uppercase font-bold">Accuracy</div>
                                    <div class="font-bold text-gray-800">${gameStats.accuracyLabel}</div>
                                    <div class="text-xs text-gray-400">ACPL: ${gameStats.acpl}</div>
                                </div>
                                <div>
                                    <div class="text-xs text-gray-500 uppercase font-bold">Style</div>
                                    <div class="font-bold text-gray-800">${gameStats.styleLabel}</div>
                                    <div class="text-xs text-gray-400">Complexity: ${gameStats.complexity}</div>
                                </div>
                            </div>
                            <div class="text-xs text-indigo-600 bg-white p-2 rounded border border-indigo-100 italic">
                                <i class="fa-solid fa-robot"></i> Use the arrows to review move-by-move.
                            </div>
                        </div>
                    `;
                    return;
                }

                // Default Start State
                contentDiv.classList.add('hidden');
                placeholder.classList.remove('hidden');
                placeholder.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles text-2xl mb-2 text-indigo-500"></i><br>Game Loaded.<br>Click <b>Review</b> for AI Analysis.';
                box.className = 'coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center'; 
                return;
            }

            contentDiv.classList.remove('hidden');
            placeholder.classList.add('hidden');

            const data = analysisData[currentMoveIndex];
            const moveNotation = `${Math.floor(currentMoveIndex / 2) + 1}${data.color === 'w' ? '.' : '...'} ${data.san}`;

            badge.innerText = data.classification;
            badge.className = `classification-badge bg-${data.classification.toLowerCase()}`;
            box.className = `coach-box ${data.classification.toLowerCase()} p-4 rounded-r-lg shadow-sm flex flex-col justify-center`;

            if(data.tactic) {
                tacticBadge.innerText = data.tactic.toUpperCase();
                tacticBadge.classList.remove('hidden');
            } else {
                tacticBadge.classList.add('hidden');
            }

            let commentData = geminiComments[currentMoveIndex + 1];
            let mainComment = "Standard move.";
            
            if (commentData) {
                if (typeof commentData === 'string') mainComment = commentData;
                else if (commentData.analysis) mainComment = commentData.analysis;
            } else {
                if (data.classification === "Best") mainComment = "Excellent find!";
                else if (data.classification === "Mistake") mainComment = "This loses advantage.";
                else if (data.classification === "Blunder") mainComment = "Critical error.";
                else if (data.classification === "Book") mainComment = "Standard opening theory.";
            }
            
            document.getElementById('coachText').innerHTML = marked.parse(mainComment);
            document.getElementById('moveNumber').innerText = moveNotation;

            const needsSuggestion = ["Inaccuracy", "Mistake", "Miss", "Blunder"].includes(data.classification);
            
            if (needsSuggestion && data.bestMoveSan && data.pv) {
                suggestionDiv.classList.remove('hidden');
                bestMoveText.innerText = data.bestMoveSan;
            } else {
                suggestionDiv.classList.add('hidden');
            }
        }

        // --- 7. INTERACTIVE MODES ---
        function stopInteractiveMode() {
            interactiveState.mode = 'none';
            interactiveState.tempGame = null;
            document.getElementById('coachBox').classList.remove('pv-active', 'practice-active');
            document.getElementById('board').classList.remove('board-pv-highlight', 'board-practice-mode');
            document.getElementById('pvModeBadge').classList.add('hidden');
            document.getElementById('practiceModeBadge').classList.add('hidden');
            document.getElementById('mainNavButtons').style.opacity = '1';
            document.getElementById('mainNavButtons').style.pointerEvents = 'auto';
            if(board) board.draggable = false; 
            updateUI();
        }

        function startPvReview() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];
            if (!data.pv) return;

            interactiveState.mode = 'pv';
            interactiveState.tempGame = new Chess(data.fenBefore);
            interactiveState.pvIndex = -1;
            interactiveState.pvMoves = [];
            const moveStrings = data.pv.split(' ');
            const limit = Math.min(moveStrings.length, 6);
            
            for(let i=0; i<limit; i++) {
                const m = moveStrings[i];
                const from = m.substring(0,2);
                const to = m.substring(2,4);
                const promotion = m.length > 4 ? m.substring(4,5) : 'q';
                const moveObj = interactiveState.tempGame.move({from, to, promotion});
                if(moveObj) interactiveState.pvMoves.push(moveObj);
                else break; 
            }
            interactiveState.tempGame.reset();
            interactiveState.tempGame.load(data.fenBefore);

            const geminiData = geminiComments[currentMoveIndex + 1];
            interactiveState.pvComments = (geminiData && geminiData.pv_explanation) ? geminiData.pv_explanation : [];

            document.getElementById('coachBox').classList.add('pv-active');
            document.getElementById('board').classList.add('board-pv-highlight');
            document.getElementById('pvModeBadge').classList.remove('hidden');
            document.getElementById('mainNavButtons').style.opacity = '0.5';
            document.getElementById('mainNavButtons').style.pointerEvents = 'none';

            board.position(data.fenBefore);
            clearArrows(); 
            updatePvUI();
        }

        function nextPvMove() {
            if (interactiveState.mode !== 'pv') return;
            if (interactiveState.pvIndex < interactiveState.pvMoves.length - 1) {
                interactiveState.pvIndex++;
                const m = interactiveState.pvMoves[interactiveState.pvIndex];
                interactiveState.tempGame.move(m);
                board.position(interactiveState.tempGame.fen());
                clearArrows();
                drawArrow(m.from, m.to, '#6366f1'); 
                updatePvUI();
            }
        }

        function prevPvMove() {
            if (interactiveState.mode !== 'pv') return;
            if (interactiveState.pvIndex >= 0) {
                interactiveState.tempGame.undo();
                interactiveState.pvIndex--;
                board.position(interactiveState.tempGame.fen());
                clearArrows();
                updatePvUI();
            }
        }

        function updatePvUI() {
            const indicator = document.getElementById('pvMoveIndicator');
            const commentText = document.getElementById('pvCommentText');
            
            if (interactiveState.pvIndex === -1) {
                indicator.innerText = "Start";
                commentText.innerHTML = "<b>Initial Position.</b><br>Click > to see why this is better.";
            } else {
                const moveObj = interactiveState.pvMoves[interactiveState.pvIndex];
                indicator.innerText = `Move ${interactiveState.pvIndex + 1}`;
                let comment = interactiveState.pvComments[interactiveState.pvIndex] || "Continuing the best line.";
                commentText.innerHTML = `<b>${moveObj.san}:</b> ${comment}`;
            }
        }

        function startPracticeMode() {
            if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
            const data = analysisData[currentMoveIndex];

            interactiveState.mode = 'practice';
            interactiveState.tempGame = new Chess(data.fenBefore);
            interactiveState.practiceTarget = data.bestMove; 

            document.getElementById('coachBox').classList.add('practice-active');
            document.getElementById('board').classList.add('board-practice-mode');
            document.getElementById('practiceModeBadge').classList.remove('hidden');
            document.getElementById('mainNavButtons').style.opacity = '0.5';
            document.getElementById('mainNavButtons').style.pointerEvents = 'none';
            document.getElementById('practiceFeedbackText').innerText = "Drag the pieces to find the best move!";
            document.getElementById('practiceFeedbackText').className = "text-sm text-gray-800 font-medium mb-3 min-h-[40px] flex items-center justify-center text-center";

            board.position(data.fenBefore);
            clearArrows();
            
            board = Chessboard('board', {
                position: data.fenBefore,
                draggable: true,
                pieceTheme: pieceTheme,
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });
            if(game.turn() === 'b') board.orientation('black');
            else board.orientation('white');
        }

        function onDragStart (source, piece, position, orientation) {
            if (interactiveState.mode !== 'practice') return false;
            if ((interactiveState.tempGame.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (interactiveState.tempGame.turn() === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }

        function onDrop (source, target) {
            if (interactiveState.mode !== 'practice') return 'snapback';
            var move = interactiveState.tempGame.move({ from: source, to: target, promotion: 'q' });
            if (move === null) return 'snapback';

            const uciMove = source + target + (move.promotion ? move.promotion : '');
            const targetUci = interactiveState.practiceTarget;
            const isCorrect = uciMove.includes(targetUci) || targetUci.includes(uciMove);

            if (isCorrect) {
                document.getElementById('practiceFeedbackText').innerHTML = "<span class='text-green-600 font-bold text-lg'><i class='fa-solid fa-check'></i> Correct!</span>";
                document.getElementById('board').classList.add('practice-success');
                setTimeout(() => {
                    alert("Great job! You found the best move.");
                    stopInteractiveMode();
                    initBoard();
                    updateUI();
                }, 500);
            } else {
                document.getElementById('practiceFeedbackText').innerHTML = "<span class='text-red-500 font-bold'><i class='fa-solid fa-xmark'></i> Incorrect. Try again.</span>";
                document.getElementById('board').classList.add('practice-fail');
                setTimeout(() => document.getElementById('board').classList.remove('practice-fail'), 500);
                interactiveState.tempGame.undo(); 
                return 'snapback';
            }
        }

        function onSnapEnd () {}

        // --- 8. ANALYSIS PIPELINE (UPDATED LOGIC) ---
        async function startAnalysis() {
            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) { alert("Please add API Key."); openSettings(); return; }
            
            isAnalyzing = true;
            const overlay = document.getElementById('analysisOverlay');
            overlay.classList.remove('hidden');
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressBar').style.width = "0%";
            document.getElementById('geminiStatus').classList.add('hidden');

            const tempGame = new Chess();
            analysisData = [];
            let openingName = "Unknown Opening";

            try {
                for (let i = 0; i < gameHistory.length; i++) {
                    if (!isAnalyzing) return; 

                    const move = gameHistory[i];
                    document.getElementById('progressBar').style.width = Math.round(((i+1)/gameHistory.length)*100) + "%";
                    document.getElementById('progressText').innerText = `Analyzing Move ${i+1}/${gameHistory.length}`;

                    const fenBefore = tempGame.fen();
                    
                    // --- BOOK CHECK ---
                    let bookMoves = [];
                    let isBook = false;
                    if (i < 15) { 
                        const bookResult = await fetchBookData(fenBefore);
                        if (bookResult) {
                            bookMoves = bookResult.moves.map(m => m.uci);
                            if (bookResult.opening) openingName = bookResult.opening.name;
                            const userUci = move.from + move.to + (move.promotion || '');
                            if (bookMoves.includes(userUci)) isBook = true;
                        }
                    }
                    
                    let tablebaseData = (getPieceCount(fenBefore) <= 7) ? await fetchTablebase(fenBefore) : null;

                    // 1. ENGINE BEFORE
                    const preMoveResult = await runStockfish(fenBefore);
                    let scoreBefore = parseEvalToNumber(preMoveResult.eval);
                    
                    // Critical Moment Detection (MultiPV)
                    let isCritical = false;
                    if (preMoveResult.lines && preMoveResult.lines.length >= 2) {
                        const l1 = preMoveResult.lines[0];
                        const l2 = preMoveResult.lines[1];

                        // Helper to get numeric score for gap calculation (handle Mate)
                        const getGapScore = (line) => {
                            if (line.type === 'mate') {
                                // +/- 10000 for mate
                                return (line.rawScore > 0) ? 10000 : -10000;
                            }
                            return line.rawScore; // Centipawns
                        };

                        const s1 = getGapScore(l1);
                        const s2 = getGapScore(l2);
                        const gap = Math.abs(s1 - s2);

                        // Threshold: 150 centipawns (1.5 pawns)
                        if (gap > 150) {
                            isCritical = true;
                        }
                    }

                    // Handle Tablebase "Truth"
                    const turnBefore = tempGame.turn();
                    if (tablebaseData === 'win') scoreBefore = (turnBefore === 'w') ? 100 : -100;
                    if (tablebaseData === 'loss') scoreBefore = (turnBefore === 'w') ? -100 : 100;

                    // 2. SIMULATE BEST MOVE
                    let bestMoveStats = { matDiff:0, centerCtrl:0, safety:0, rawMaterial:0 };
                    let bestMoveSan = preMoveResult.bestMove;
                    let bestLineSan = "";
                    let bestIsMate = preMoveResult.eval.toString().startsWith("M");

                    if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                        const simGame = new Chess(fenBefore);
                        const bm = simGame.move({ from: preMoveResult.bestMove.substring(0,2), to: preMoveResult.bestMove.substring(2,4), promotion: 'q' });
                        if(bm) {
                            bestMoveSan = bm.san;
                            bestMoveStats = getDetailedMoveStats(simGame, bm, fenBefore);
                        }
                        if(preMoveResult.pv) bestLineSan = uciToSan(fenBefore, preMoveResult.pv);
                    }

                    // 3. EXECUTE USER MOVE
                    tempGame.move(move.san);
                    const fenAfter = tempGame.fen();
                    const userMoveStats = getDetailedMoveStats(tempGame, move, fenBefore);

                    // 4. POST MOVE ANALYSIS
                    const isMate = tempGame.in_checkmate();
                    const isDraw = tempGame.in_draw() || tempGame.in_stalemate();
                    let scoreAfter = 0;
                    let evAfterStr = "";
                    
                    if (isMate) {
                        scoreAfter = (move.color === 'w') ? 100 : -100;
                        evAfterStr = "M0"; 
                    } else if (isDraw) {
                        scoreAfter = 0;
                        evAfterStr = "0.00";
                    } else {
                        const postMoveResult = await runStockfish(fenAfter);
                        evAfterStr = postMoveResult.eval;
                        scoreAfter = parseEvalToNumber(postMoveResult.eval);
                    }

                    // --- CLASSIFICATION LOGIC FIXES ---
                    let cls = "Neutral";
                    let evalDiff = (move.color === 'w') ? (scoreBefore - scoreAfter) : (scoreAfter - scoreBefore);

                    // Context Flags
                    const isUserWinning = (move.color === 'w' && scoreBefore > 10) || (move.color === 'b' && scoreBefore < -10);
                    const isUserLost = (move.color === 'w' && scoreBefore < -10) || (move.color === 'b' && scoreBefore > 10);
                    const userFoundMate = evAfterStr.toString().startsWith("M") && ((move.color === 'w' && scoreAfter > 0) || (move.color === 'b' && scoreAfter < 0));

                    // 1. Absolute Truths
                    if (isMate) {
                         cls = "Best"; 
                    } 
                    else if (scoreAfter === -100 || (evAfterStr.toString().startsWith('M') && !userFoundMate)) {
                         cls = "Blunder"; // Forced mate detected against user
                    }
                    else if (isBook) {
                         cls = "Book";
                    }
                    else if (move.san === bestMoveSan) {
                         cls = "Best";
                    }
                    // 2. "Mate Optimization" (Don't punish finding a slower mate)
                    else if (bestIsMate && userFoundMate) {
                         cls = "Excellent";
                    }
                    // 3. "Resignation Threshold" (Don't analyze blunders in lost positions)
                    else if (isUserLost) {
                         if (evalDiff > 5) cls = "Mistake"; 
                         else cls = "Neutral";
                    }
                    // 4. "Winning Cushion" (Don't analyze inaccuracies when winning huge)
                    else if (isUserWinning) {
                         if (evalDiff > 5) cls = "Mistake"; 
                         else cls = "Good"; 
                    }
                    else {
                         // Standard Mid-Game Logic
                         if (evalDiff <= 0.3) cls = "Best";
                         else if (evalDiff <= 0.8) cls = "Excellent";
                         else if (evalDiff <= 1.5) cls = "Good";
                         else if (evalDiff <= 2.5) cls = "Inaccuracy"; 
                         else if (evalDiff <= 4.0) cls = "Mistake"; 
                         else cls = "Blunder"; 
                    }

                    // --- ENHANCED MATERIAL LOGIC ---
                    const startMaterial = getMaterialScore(fenBefore);
                    const userMaterial = userMoveStats.rawMaterial; // From getDetailedMoveStats
                    const bestMaterial = bestMoveStats.rawMaterial; // From getDetailedMoveStats

                    // Calculate absolute changes for the current mover
                    let userGain = (move.color === 'w') ? (userMaterial - startMaterial) : (startMaterial - userMaterial);
                    let bestGain = (move.color === 'w') ? (bestMaterial - startMaterial) : (startMaterial - bestMaterial);

                    // Check protection using the state AFTER the move
                    const isProtected = isSquareProtected(tempGame, move.to, move.color);
                    const isCapture = move.flags.includes('c') || move.captured;

                    let materialMsg = "";

                    // 1. HUNG_PIECE: User lost material, Best move didn't, and the square is NOT protected
                    if (userGain < 0 && bestGain >= 0 && !isProtected) {
                        materialMsg = "HUNG_PIECE";
                    }
                    // 2. BAD_TRADE: User lost material, Best move didn't, but square IS protected
                    else if (userGain < 0 && bestGain >= 0 && isProtected) {
                        materialMsg = "BAD_TRADE";
                    }
                    // 3. TRADED_AWAY_ADVANTAGE: Equal trade (Gain=0) but classified as error
                    else if (userGain === 0 && isCapture && (cls === "Mistake" || cls === "Blunder")) {
                         materialMsg = "TRADED_AWAY_ADVANTAGE";
                    }
                    // 4. MISSED_WIN: Best move wins material, User didn't
                    else if (bestGain > 0 && userGain <= 0 && Math.abs(bestGain - userGain) >= 1) {
                        materialMsg = "MISSED_WIN";
                    }

                    const tacticAlert = isMate ? "Checkmate" : detectTactics(tempGame, move);

                    analysisData.push({
                        eval: evAfterStr, 
                        wdl: preMoveResult.wdl,
                        bestMove: preMoveResult.bestMove,
                        bestMoveSan: bestMoveSan,
                        pv: preMoveResult.pv,
                        pvSan: bestLineSan,
                        san: move.san,
                        color: move.color,
                        classification: cls,
                        fenBefore: fenBefore,
                        opening: openingName,
                        tactic: tacticAlert,
                        control: calculateControl(tempGame),
                        isMate: isMate,
                        isCritical: isCritical,
                        stats: { user: userMoveStats, best: bestMoveStats },
                        materialStatus: materialMsg
                    });
                }

                if (!isAnalyzing) return;

                // =========================================================
                // === NEW AGGREGATION BLOCK: Calculate Game Character ===
                // =========================================================

                let totalLoss = 0;
                let scoredMoves = 0;
                let complexitySum = 0;
                let prevEval = 0;

                // Define ACPL approximation values based on classification
                const ACPL_MAP = {
                    "Best": 0, "Excellent": 5, "Good": 20,
                    "Inaccuracy": 60, "Mistake": 150, "Blunder": 350, "Neutral": 0, "Book": 0
                };

                analysisData.forEach(d => {
                    // ACPL Calculation (Centipawn Loss approximation)
                    totalLoss += ACPL_MAP[d.classification] || 0;

                    // Complexity Calculation (Average Eval Swing)
                    let currentEval = parseEvalToNumber(d.eval);
                    // Clamp mate scores for complexity math (20.0 instead of 100.0)
                    if (d.eval.toString().includes('M')) currentEval = d.eval.includes('-') ? -20 : 20;

                    complexitySum += Math.abs(currentEval - prevEval);
                    prevEval = currentEval;

                    scoredMoves++;
                });

                const acpl = Math.round(totalLoss / (scoredMoves || 1));
                const complexityScore = (complexitySum / (scoredMoves || 1)).toFixed(2);

                // Generate the narrative tags for the prompt
                let accuracyLabel = "Average";
                if (acpl < 25) accuracyLabel = "Master-Level Precision";
                else if (acpl < 50) accuracyLabel = "Strong Club Player";
                else if (acpl > 100) accuracyLabel = "Erratic and Risky";

                let gameTypeLabel = "Standard Fight";
                if (complexityScore < 0.8) gameTypeLabel = "Positional Grind (Low Complexity)";
                else if (complexityScore > 3.0) gameTypeLabel = "Wild Tactical Chaos (High Complexity)";

                const gameSummary = `
[GAME SUMMARY]
- Player Accuracy: ${accuracyLabel} (ACPL: ${acpl})
- Game Style: ${gameTypeLabel} (Complexity: ${complexityScore})
- Overall Tip: Use this data to define the 'Tone' and 'Focus' of the entire report.
`;

                // Store stats for UI
                gameStats = {
                    acpl: acpl,
                    accuracyLabel: accuracyLabel,
                    complexity: complexityScore,
                    styleLabel: gameTypeLabel
                };

                document.getElementById('statusTitle').innerText = "Consulting Coach...";
                document.getElementById('geminiStatus').classList.remove('hidden');
                document.getElementById('progressBar').className = "h-full bg-purple-500 animate-pulse";
                await getGeminiCommentary(apiKey, document.getElementById('analysisFocus').value, openingName, gameSummary);

            } catch (err) {
                console.error(err);
                alert("Analysis Error: " + err.message);
            } finally {
                overlay.classList.add('hidden');
                document.getElementById('analyzeBtn').disabled = false;
                isAnalyzing = false;
                if (analysisData.length > 0) {
                   if(currentMoveIndex === -1) nextMove(); 
                   else updateUI();
                }
            }
        }

        function runStockfish(fen) {
            return new Promise(resolve => {
                if (!stockfish) initStockfish();
                const tId = setTimeout(() => resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: null, lines: [] }), 4000);
                stockfish.postMessage('stop');
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth 12'); 

                let best="-", ev="0.00", pv="", wdl=null;
                let lines = [];

                const list = (e) => {
                    const l = e.data;

                    if (l.startsWith('info') && l.includes('multipv') && l.includes('score')) {
                        const matchPv = l.match(/multipv (\d+)/);
                        const matchScore = l.match(/score (cp|mate) (-?\d+)/);
                        const matchPvStr = l.split(' pv ')[1];

                        if (matchPv && matchScore && matchPvStr) {
                            const lineIdx = parseInt(matchPv[1]) - 1;
                            let rawVal = parseInt(matchScore[2]);
                            let absScore = (fen.includes(' b ') ? -rawVal : rawVal);
                            let scoreStr = (matchScore[1] === 'mate') ? "M" + absScore : (absScore / 100).toFixed(2);

                            lines[lineIdx] = {
                                score: scoreStr,
                                pv: matchPvStr,
                                rawScore: absScore,
                                type: matchScore[1]
                            };

                            if (lineIdx === 0) {
                                pv = matchPvStr;
                                ev = scoreStr;
                            }
                        }
                    }

                    if (l.includes(' wdl ')) { const m=l.match(/wdl (\d+) (\d+) (\d+)/); if(m) wdl=[parseInt(m[1]), parseInt(m[2]), parseInt(m[3])]; }

                    if (l.startsWith('bestmove')) {
                        clearTimeout(tId);
                        best = l.split(' ')[1];
                        stockfish.removeEventListener('message', list);

                        if (lines.length === 0) {
                             let fallbackRaw = parseFloat(ev) * 100;
                             if(ev.toString().startsWith('M')) fallbackRaw = parseInt(ev.substring(1));
                             lines.push({ score: ev, pv: pv, rawScore: fallbackRaw, type: ev.toString().startsWith('M')?'mate':'cp' });
                        }

                        if(!wdl && !ev.toString().startsWith('M')) wdl = estimateWDL(parseFloat(ev));
                        resolve({ eval: ev, bestMove: best, pv: pv, wdl: wdl, lines: lines });
                    }
                };
                stockfish.addEventListener('message', list);
            });
        }

        // --- 9. HELPERS ---
        function getDetailedMoveStats(gameObj, moveObj, oldFen) {
            const getMat = (fen) => {
                let s = 0;
                const vals = {p:1, n:3, b:3, r:5, q:9, k:0};
                fen.split(' ')[0].split('').forEach(c => {
                    if(vals[c.toLowerCase()]) s += (c === c.toUpperCase() ? vals[c.toLowerCase()] : -vals[c.toLowerCase()]);
                });
                return s; // Positive = White ahead, Negative = Black ahead
            };
            
            const rawMat = getMat(gameObj.fen());
            
            const getCenter = (gameInst) => {
                const ctrl = calculateControl(gameInst);
                const centerIndices = [35, 36, 27, 28];
                let score = 0;
                centerIndices.forEach(i => score += ctrl[i]);
                return (moveObj.color === 'w') ? score : -score;
            };
            return {
                rawMaterial: rawMat,
                material: (moveObj.color === 'w') ? rawMat : -rawMat,
                center: getCenter(gameObj),
                captured: (moveObj.captured || null),
                isCheck: gameObj.in_check()
            };
        }

        function parseEvalToNumber(evalStr) {
            if (typeof evalStr === 'string' && evalStr.startsWith('M')) {
                return parseInt(evalStr.replace('M', '')) > 0 ? 10 : -10;
            }
            return parseFloat(evalStr);
        }

        function estimateWDL(ev) {
            const w = 500 + (500 * (2 / (1 + Math.exp(-0.004 * (ev * 100))) - 1));
            return [Math.round(w), 0, Math.round(1000 - w)];
        }

        function getPieceCount(fen) { return fen.split(' ')[0].replace(/[^a-zA-Z]/g,'').length; }

        function getMaterialScore(fen) {
            let s = 0;
            const vals = {p:1, n:3, b:3, r:5, q:9, k:0};
            fen.split(' ')[0].split('').forEach(c => {
                if(vals[c.toLowerCase()]) {
                    s += (c === c.toUpperCase() ? vals[c.toLowerCase()] : -vals[c.toLowerCase()]);
                }
            });
            return s;
        }

        async function fetchBookData(fen) {
            try { 
                const res = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`);
                if(res.ok) return await res.json();
            } catch(e){ return null; }
            return null;
        }

        async function fetchTablebase(fen) {
            try { return (await (await fetch(`https://tablebase.lichess.ovh/standard?fen=${fen}`)).json()).category; } catch(e){return null;}
        }

        function isSquareProtected(gameObj, targetSq, movedColor) {
            const ctrl = calculateControl(gameObj);
            const idx = ['a8','b8','c8','d8','e8','f8','g8','h8','a7','b7','c7','d7','e7','f7','g7','h7','a6','b6','c6','d6','e6','f6','g6','h6','a5','b5','c5','d5','e5','f5','g5','h5','a4','b4','c4','d4','e4','f4','g4','h4','a3','b3','c3','d3','e3','f3','g3','h3','a2','b2','c2','d2','e2','f2','g2','h2','a1','b1','c1','d1','e1','f1','g1','h1'].indexOf(targetSq);
            if (idx === -1) return false;

            if (movedColor === 'w') return ctrl[idx] > 0;
            if (movedColor === 'b') return ctrl[idx] < 0;
            return false;
        }

        function detectTactics(g, m) {
            if (m.flags.includes('c') || m.flags.includes('e')) return "Capture";
            if (m.san.includes('+')) return "Check";
            if (m.flags.includes('p')) return "Promotion";
            return null;
        }

        function calculateControl(gameObj) {
            let ctrl = new Array(64).fill(0);
            const squares = ['a8','b8','c8','d8','e8','f8','g8','h8','a7','b7','c7','d7','e7','f7','g7','h7','a6','b6','c6','d6','e6','f6','g6','h6','a5','b5','c5','d5','e5','f5','g5','h5','a4','b4','c4','d4','e4','f4','g4','h4','a3','b3','c3','d3','e3','f3','g3','h3','a2','b2','c2','d2','e2','f2','g2','h2','a1','b1','c1','d1','e1','f1','g1','h1'];
            const turn = gameObj.turn();
            gameObj.moves({verbose:true}).forEach(m => {
                const idx = squares.indexOf(m.to);
                if(idx>-1) ctrl[idx] += (turn==='w'?1:-1);
            });
            const fen = gameObj.fen();
            const oppFen = fen.replace(turn==='w'?' w ':' b ', turn==='w'?' b ':' w ').replace(/ [a-h][36] /, ' - '); 
            const g2 = new Chess(oppFen);
                g2.moves({verbose:true}).forEach(m => {
                const idx = squares.indexOf(m.to);
                if(idx>-1) ctrl[idx] += (turn==='w'?-1:1);
            });
            return ctrl;
        }
        
        function uciToSan(fen, pv) {
            if(!pv) return "";
            const t = new Chess(fen);
            let s = "";
            let mvs = pv.split(' ');
            for(let m of mvs) {
                let mo = t.move({from:m.substring(0,2), to:m.substring(2,4), promotion: m.length>4?m.substring(4,5):undefined});
                if(mo) s += mo.san + " "; else break;
            }
            return s;
        }

        // --- 10. GEMINI API (UPDATED PROMPT with Game Summary Context) ---
        async function getGeminiCommentary(key, focus, opening, gameSummary) {
            let log = gameSummary; // Start the log with the overall game summary
            
            // 1. Compress Opening Book moves
            let bookLimit = 0;
            for(let i=0; i<analysisData.length; i++) {
                if(analysisData[i].classification !== 'Book') break;
                bookLimit = i;
            }
            
            if (bookLimit > 2) {
                log += `[OPENING SUMMARY]: The game started with ${opening}. Moves 1-${bookLimit+1} followed standard theory.\n\n`;
            }

            // 2. Build Move Log
            analysisData.forEach((d, i) => {
                // Skip individual book moves if we summarized them
                if (i <= bookLimit && d.classification === 'Book') return;

                const isUserTurn = (focus === 'both' || focus === d.color);
                if (!isUserTurn) return;

                const isError = ["Mistake", "Blunder", "Miss", "Inaccuracy"].includes(d.classification);
                const isInteresting = ["Best", "Great", "Brilliant", "Excellent"].includes(d.classification);
                const isMate = !!d.isMate;
                
                if (isError || d.tactic || isMate || (isInteresting && i % 4 === 0)) {
                    
                    const moveInfo = `Move ${i + 1} (${d.color}): ${d.san}`;
                    
                    // Interpret Score for Gemini
                    let scoreNum = parseEvalToNumber(d.eval);
                    let stateLabel = "Equal";
                    if (scoreNum > 1.0) stateLabel = "White Slight Edge";
                    if (scoreNum > 3.0) stateLabel = "White Winning";
                    if (scoreNum < -1.0) stateLabel = "Black Slight Edge";
                    if (scoreNum < -3.0) stateLabel = "Black Winning";
                    if (d.eval.toString().includes("M")) stateLabel = "Forced Mate Detected";

                    const stats = `[Eval: ${d.eval} (${stateLabel})] [Class: ${d.classification}]`;
                    
                    let comparison = "";
                    if (d.stats && d.stats.best) {
                        const u = d.stats.user;
                        const b = d.stats.best;
                        comparison = `Stats: User(Mat:${u.material}, Center:${u.center}) vs Best(Mat:${b.material}, Center:${b.center})`;
                    }

                    // --- NEW CONTEXT INJECTION ---
                    if (d.materialStatus === "HUNG_PIECE") {
                        comparison += ` [HUNG_PIECE: User left a piece completely undefended]`;
                    } else if (d.materialStatus === "BAD_TRADE") {
                        comparison += ` [BAD_TRADE: User initiated or allowed an exchange that lost material value]`;
                    } else if (d.materialStatus === "TRADED_AWAY_ADVANTAGE") {
                        comparison += ` [STRATEGIC ERROR: Material is equal, but this exchange significantly worsened the position]`;
                    } else if (d.materialStatus === "MISSED_WIN") {
                        comparison += ` [MISSED TACTIC: User missed a chance to win material. Best move captures something.]`;
                    }

                    let tacticInfo = d.tactic ? `[TACTIC: ${d.tactic}]` : '';
                    if (isMate) tacticInfo = "[GAME OVER: CHECKMATE]"; 
                    
                    // Critical Moment Tag
                    if (d.isCritical && d.classification === 'Best') {
                        tacticInfo += " [HERO MOMENT: The user found the ONLY move that survives/wins!]";
                    }

                    const bestLineInfo = isError ? `\n   -> Engine Best: ${d.bestMoveSan}\n   -> Engine Line: ${d.pvSan}` : '';
                    
                    log += `${moveInfo} ${stats} ${tacticInfo} ${comparison}${bestLineInfo}\nFEN: ${d.fenBefore}\n\n`;
                }
            });

            if (log.length < 50) log = gameSummary + "\nGame was too short for detailed move analysis.";

            const prompt = `
            You are a Grandmaster Chess Coach.
            
            **TASK:**
            Provide brief, insightful commentary on the provided chess game log.

            **TONE ADJUSTMENT (CRITICAL):**
            The [GAME SUMMARY] contains the overall ACPL and Complexity. Use this to set the tone for your move comments:

            1. **Master-Level Precision** -> Adopt persona: "The Encouraging Mentor".
               - Be enthusiastic and supportive.
               - Frame 'Inaccuracy' as minor technical oversights.
               - Congratulate them on sharp play.

            2. **Wild Tactical Chaos** -> Adopt persona: "The Safety Officer".
               - Hyper-aware of defense and King Safety.
               - Emphasize WHY a move avoided a trap.
               - Use phrases like "in this minefield" or "navigated the tactics".

            3. **Erratic and Risky** -> Adopt persona: "The Consistency Coach".
               - Firm but patient.
               - For Blunders, emphasize checking every line once more.
               - For Good moves, highlight the value of simple, steady play.

            **GENERAL GUIDELINES:**
            - **Opening:** Be educational. Mention the opening goals.
            - **Endgame:** If the game is "Winning" or "Lost" (Eval > 3 or < -3), stop nitpicking small inaccuracies.
            
            **OUTPUT RULES (STRICT):**
            1. **Natural Language:** Do NOT use tags like [DATA] or [BLUNDER] in the final text.
            2. **Material Handling:**
               - **[HUNG_PIECE]**: Scold the player for leaving a piece completely undefended.
               - **[BAD_TRADE]**: Explain that the piece was defended, but the swap resulted in a loss of material value (e.g., trading a Rook for a Knight).
               - **[STRATEGIC ERROR]**: Do NOT mention 'free pieces' or 'hanging' material. Instead, focus on how the trade simplified the game for the opponent or ruined the player's coordination.
               - **[MISSED TACTIC]**: Explain that they missed a free capture.
            3. **Accuracy:** Trust the [Eval] tag provided.

            **JSON Format:**
            {
                "12": {
                    "analysis": "This push weakens the king. Better was Nf3 to develop.",
                    "pv_explanation": ["Nf3 controls the center"] 
                }
            }

            **Game Log:**
            ${log}
            `;

            try {
                const res = await fetch(MODEL_ENDPOINT+`?key=${key}`, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const d = await res.json();
                const rawText = d.candidates[0].content.parts[0].text;

                // Robust JSON Extraction
                const jsonStart = rawText.indexOf('{');
                const jsonEnd = rawText.lastIndexOf('}');

                if (jsonStart !== -1 && jsonEnd !== -1) {
                    const jsonStr = rawText.substring(jsonStart, jsonEnd + 1);
                    geminiComments = JSON.parse(jsonStr);
                } else {
                    throw new Error("No JSON found in response");
                }
            } catch(e) {
                console.error("Gemini API Error:", e);
                geminiComments = {};
            }
        }

        // --- 11. CHAT ---
        async function sendChatMessage() {
            const txt = document.getElementById('chatInput').value;
            const key = localStorage.getItem('gemini_api_key');
            if(!key || !txt) return;
            const hist = document.getElementById('chatHistory');
            hist.innerHTML += `<div class="bg-indigo-50 p-2 rounded mb-2 text-right"><b>You:</b> ${txt}</div>`;
            document.getElementById('chatInput').value = "";
            hist.scrollTop = hist.scrollHeight;
            try {
                const res = await fetch(MODEL_ENDPOINT+`?key=${key}`, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: `Context: PGN=${game.pgn()}, FEN=${game.fen()}. User: ${txt}` }] }] })
                });
                const d = await res.json();
                hist.innerHTML += `<div class="text-left mb-2 text-gray-700"><b>Coach:</b> ${marked.parse(d.candidates[0].content.parts[0].text)}</div>`;
                hist.scrollTop = hist.scrollHeight;
            } catch(e) { hist.innerHTML += `<div class="text-red-500">Error.</div>`; }
        }
        function handleChatEnter(e) { if(e.key === 'Enter') sendChatMessage(); }
        function saveSettings() { localStorage.setItem('gemini_api_key', document.getElementById('apiKeyInput').value); document.getElementById('settingsModal').classList.add('hidden'); }
        function openSettings() { document.getElementById('apiKeyInput').value = localStorage.getItem('gemini_api_key')||''; document.getElementById('settingsModal').classList.remove('hidden'); }
        function cancelAnalysis() { isAnalyzing = false; document.getElementById('analysisOverlay').classList.add('hidden'); document.getElementById('analyzeBtn').disabled = false; }
        
        function copyAnalysisToClipboard() {
            if (!analysisData || analysisData.length === 0) {
                alert("No analysis available to copy. Run the Review first.");
                return;
            }

            let text = "Game Analysis Report\n--------------------\n\n";

            analysisData.forEach((move, index) => {
                const moveNum = Math.floor(index / 2) + 1;
                const turn = move.color === 'w' ? "White" : "Black";
                const dot = move.color === 'w' ? "." : "...";

                let evalText = move.eval;
                if (typeof evalText === 'string' && !evalText.startsWith('M') && !evalText.startsWith('-') && parseFloat(evalText) > 0) {
                    evalText = '+' + evalText;
                }

                let winChance = "N/A";
                if (move.wdl) {
                    winChance = (move.wdl[0] / 10).toFixed(1) + "%";
                }

                let comment = "";
                const gData = geminiComments[index + 1];
                if (gData) {
                    if (typeof gData === 'string') comment = gData;
                    else if (gData.analysis) comment = gData.analysis;
                }

                text += `${moveNum}${dot} ${move.san} (${turn})\n`;
                text += `   Eval: ${evalText} | Win Chance: ${winChance} | Class: ${move.classification}\n`;
                if (comment) {
                    text += `   Coach: ${comment}\n`;
                }
                text += "\n";
            });

            navigator.clipboard.writeText(text).then(() => {
                alert("Analysis copied to clipboard!");
            }).catch(err => {
                console.error("Copy failed", err);
                alert("Failed to copy analysis.");
            });
        }

    </script>
</body>
</html>
