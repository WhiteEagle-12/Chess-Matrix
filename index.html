<script>
    // --- CONSTANTS ---
    const STOCKFISH_URL = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js';
    const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';
    
    // --- STATE ---
    let game = new Chess();
    let board = null;
    let stockfish = null;
    let gameHistory = []; 
    let currentMoveIndex = -1; 
    
    // Rich Analysis Data Storage
    let analysisData = []; 
    let geminiComments = {}; 
    let isAnalyzing = false;
    
    // PV Review State
    let pvState = {
        active: false,
        moves: [], 
        comments: [], 
        currentIndex: -1, 
        startFen: "",
        tempGame: null 
    };

    // --- INIT ---
    window.addEventListener('DOMContentLoaded', () => {
        initBoard();
        initStockfish();
        loadSettings();
        
        // Quick visual fix for mobile
        setTimeout(() => { if(board) board.resize(); }, 300);

        // Auto-open settings if no key
        if (!localStorage.getItem('gemini_api_key')) {
            openSettings();
        }
    });

    // --- 1. BOARD & PIECES ---
    function pieceTheme(piece) {
        return 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/' + piece.toLowerCase() + '.png';
    }

    function initBoard() {
        board = Chessboard('board', {
            position: 'start',
            draggable: false, 
            pieceTheme: pieceTheme
        });
        window.addEventListener('resize', board.resize);
    }
    
    function flipBoard() {
        if(board) board.flip();
        updateUI(); // Re-render heatmaps if active
    }

    // --- 2. STOCKFISH ENGINE ---
    function initStockfish() {
        try {
            const blob = new Blob([`importScripts('${STOCKFISH_URL}');`], {type: 'application/javascript'});
            stockfish = new Worker(URL.createObjectURL(blob));
            
            stockfish.postMessage('uci');
            // Enable Win-Draw-Loss stats for better human interpretation
            stockfish.postMessage('setoption name UCI_ShowWDL value true'); 
        } catch (e) {
            console.error("Stockfish init failed:", e);
            alert("Failed to load Stockfish. Please check your connection.");
        }
    }

    // --- 3. GAME LOADING ---
    function loadPGN() {
        const btn = document.getElementById('loadPgnBtn');
        const originalText = btn.innerText;
        btn.innerText = "Loading...";

        setTimeout(() => {
            const pgn = document.getElementById('pgnInput').value.trim();
            if (!pgn) { btn.innerText = originalText; return; }

            try {
                game.reset();
                let success = game.load_pgn(pgn);
                if (!success) {
                    // Try to clean non-standard PGNs
                    const cleanPgn = pgn.replace(/\{.*?\}/g, '').replace(/\$\d+/g, '');
                    success = game.load_pgn(cleanPgn);
                }

                if (!success) throw new Error("Parse failed");

                gameHistory = game.history({ verbose: true });
                game.reset();
                currentMoveIndex = -1;
                board.position(game.fen());
                board.orientation('white'); 
                
                analysisData = [];
                geminiComments = {};
                stopPvReview(); 
                
                updateUI();
                document.getElementById('pgnModal').classList.add('hidden');
                document.getElementById('gameStatus').innerText = "Game Loaded. Click Review.";
                document.getElementById('feedbackPlaceholder').innerHTML = '<i class="fa-solid fa-wand-magic-sparkles text-2xl mb-2 text-indigo-500"></i><br>Game Loaded.<br>Click <b>Review</b> for AI Analysis.';
                document.getElementById('pgnInput').value = ''; 
                
                setTimeout(() => board.resize(), 100);

            } catch (e) {
                alert("Invalid PGN. Please paste a standard PGN format.");
                console.error(e);
            } finally {
                btn.innerText = originalText;
            }
        }, 50);
    }

    // --- 4. NAVIGATION ---
    function updateUI() {
        if(pvState.active) return;
        
        board.position(game.fen());
        
        const turn = game.turn();
        document.getElementById('turnIndicator').className = `w-3 h-3 rounded-full border-2 border-black ${turn === 'w' ? 'bg-white' : 'bg-black'}`;

        updateCoachBox();
        updateEvalBar();
        renderThreatMap(); // New: Visual Heatmap
    }

    function nextMove() {
        if(pvState.active) return;
        if (currentMoveIndex < gameHistory.length - 1) {
            currentMoveIndex++;
            game.move(gameHistory[currentMoveIndex]);
            updateUI();
        }
    }

    function prevMove() {
        if(pvState.active) return;
        if (currentMoveIndex >= 0) {
            game.undo();
            currentMoveIndex--;
            updateUI();
        }
    }

    function goToStart() {
        if(pvState.active) return;
        game.reset();
        currentMoveIndex = -1;
        updateUI();
    }

    function goToEnd() {
        if(pvState.active) return;
        while (currentMoveIndex < gameHistory.length - 1) {
            currentMoveIndex++;
            game.move(gameHistory[currentMoveIndex]);
        }
        updateUI();
    }

    // --- 5. VISUAL LAYERS (HEATMAPS) ---
    function renderThreatMap() {
        // Remove existing overlays
        $('.square-55d63').find('.threat-overlay').remove();
        
        // Only show if we have analysis data for this position
        if (currentMoveIndex === -1 || !analysisData[currentMoveIndex]) return;

        const data = analysisData[currentMoveIndex];
        const control = data.control; // { square: score } positive=white, negative=black

        if(!control) return;

        for (const [sq, val] of Object.entries(control)) {
            if (Math.abs(val) > 1) { // Only show significant control
                const color = val > 0 ? 'rgba(100, 255, 100, 0.4)' : 'rgba(255, 100, 100, 0.4)';
                const $square = $(`.square-${sq}`);
                if ($square.length) {
                    $square.append(`<div class="threat-overlay" style="position:absolute;width:100%;height:100%;background:${color};pointer-events:none;z-index:1;"></div>`);
                }
            }
        }
    }

    // --- 6. DATA CALCULATION HELPER (The "Semantic" Brain) ---
    function calculateBoardControl(fen) {
        const tempGame = new Chess(fen);
        const board = tempGame.board(); // 8x8 array
        let control = {}; 
        // Simple heuristic: Count attackers for every square
        // This is a simplified client-side check. 
        // A full engine check is expensive, so we approximate.
        
        const SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 
                         'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',
                         'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',
                         'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',
                         'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',
                         'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',
                         'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',
                         'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];

        SQUARES.forEach(sq => {
            let score = 0;
            // Who attacks this square?
            // Note: chess.js 0.10.x doesn't have `attackers()` in all versions. 
            // If it fails, we return empty.
            try {
                // Approximate control by piece presence and pawn structure (simplified)
                const piece = tempGame.get(sq);
                if(piece) {
                    score += (piece.color === 'w' ? 1 : -1) * 2;
                }
            } catch(e) {}
            control[sq] = score;
        });

        // Add Center Bonus
        ['d4','e4','d5','e5'].forEach(sq => {
            if(control[sq]) control[sq] *= 1.5;
        });

        return control;
    }

    // --- 7. ANALYSIS & COACHING ---
    function updateEvalBar() {
        let evalVal = 0.00;
        const barFill = document.getElementById('visualEvalBar');
        const evalText = document.getElementById('evalText');
        
        if (currentMoveIndex >= 0 && analysisData[currentMoveIndex]) {
            const data = analysisData[currentMoveIndex];
            if (typeof data.eval === 'string' && data.eval.startsWith('M')) {
                const mateIn = parseInt(data.eval.substring(1));
                evalVal = mateIn > 0 ? 10 : -10; 
                evalText.innerText = `M${Math.abs(mateIn)}`;
            } else {
                evalVal = parseFloat(data.eval);
                evalText.innerText = Math.abs(evalVal).toFixed(2);
            }
        } else {
            evalText.innerText = "0.30";
            evalVal = 0.3;
        }

        const clampedEval = Math.max(-5, Math.min(5, evalVal));
        const percentage = 50 + (clampedEval * 10); 
        barFill.style.height = `${percentage}%`;
        
        // Color text based on advantage
        evalText.style.color = Math.abs(percentage - 50) > 40 ? '#333' : '#999';
    }

    function updateCoachBox() {
        if(pvState.active) return; 

        const contentDiv = document.getElementById('feedbackContent');
        const placeholder = document.getElementById('feedbackPlaceholder');
        const box = document.getElementById('coachBox');
        const badge = document.getElementById('moveClassBadge');
        const suggestionDiv = document.getElementById('bestMoveSuggestion');
        const bestMoveText = document.getElementById('bestMoveText');

        if (analysisData.length === 0 || currentMoveIndex === -1) {
            contentDiv.classList.add('hidden');
            placeholder.classList.remove('hidden');
            box.className = 'coach-box p-4 rounded-r-lg shadow-sm flex flex-col justify-center'; 
            return;
        }

        contentDiv.classList.remove('hidden');
        placeholder.classList.add('hidden');

        const data = analysisData[currentMoveIndex];
        const moveInfo = gameHistory[currentMoveIndex];
        const moveNum = Math.floor(currentMoveIndex / 2) + 1;
        const moveNotation = `${moveNum}${moveInfo.color === 'w' ? '.' : '...'} ${moveInfo.san}`;

        badge.innerText = data.classification;
        badge.className = `classification-badge bg-${data.classification.toLowerCase()}`;
        box.className = `coach-box ${data.classification.toLowerCase()} p-4 rounded-r-lg shadow-sm flex flex-col justify-center`;

        // Display main commentary
        let commentData = geminiComments[currentMoveIndex + 1];
        let mainComment = "Standard move.";
        
        if (commentData) {
            if (typeof commentData === 'string') mainComment = commentData;
            else if (commentData.analysis) mainComment = commentData.analysis;
        } else {
            // Fallback templates
            const opening = data.opening ? `<b>${data.opening}</b><br>` : "";
            const wdl = data.wdl ? `<br><span class="text-xs text-gray-500">Win Chance: ${data.wdl}</span>` : "";
            
            if (data.classification === "Best") mainComment = `${opening}Excellent find! Top engine move.${wdl}`;
            else if (data.classification === "Mistake") mainComment = `${opening}This loses advantage. ${wdl}`;
            else if (data.classification === "Blunder") mainComment = `${opening}Critical error. ${wdl}`;
        }
        
        document.getElementById('coachText').innerHTML = marked.parse(mainComment);
        document.getElementById('moveNumber').innerText = moveNotation;

        // Handle Suggestions
        const needsSuggestion = ["Inaccuracy", "Mistake", "Miss", "Blunder"].includes(data.classification);
        if (needsSuggestion && data.bestMoveSan && data.pv) {
            suggestionDiv.classList.remove('hidden');
            bestMoveText.innerText = data.bestMoveSan;
        } else {
            suggestionDiv.classList.add('hidden');
        }
    }

    // --- 8. PV REVIEW (BEST LINE) ---
    function startPvReview() {
        if (currentMoveIndex < 0 || !analysisData[currentMoveIndex]) return;
        const data = analysisData[currentMoveIndex];
        if (!data.pv) { alert("No line available."); return; }

        pvState.active = true;
        pvState.startFen = data.fenBefore; 
        pvState.tempGame = new Chess(data.fenBefore);
        pvState.currentIndex = -1;
        
        pvState.moves = [];
        const moveStrings = data.pv.split(' ');
        const limit = Math.min(moveStrings.length, 8); // Deeper look
        
        for(let i=0; i<limit; i++) {
            const m = moveStrings[i];
            const from = m.substring(0,2);
            const to = m.substring(2,4);
            const promotion = m.length > 4 ? m.substring(4,5) : 'q';
            
            const moveObj = pvState.tempGame.move({from, to, promotion});
            if(moveObj) pvState.moves.push(moveObj);
            else break; 
        }
        
        pvState.tempGame.load(data.fenBefore);

        // Get Geminin explanations for the line if they exist
        pvState.comments = [];
        const geminiData = geminiComments[currentMoveIndex + 1];
        if (geminiData && geminiData.pv_explanation) {
            pvState.comments = geminiData.pv_explanation; 
        }

        const box = document.getElementById('coachBox');
        box.classList.add('pv-active');
        document.getElementById('board').classList.add('board-pv-highlight');
        document.getElementById('pvModeBadge').classList.remove('hidden');
        document.getElementById('mainNavButtons').style.opacity = '0.5';
        document.getElementById('mainNavButtons').style.pointerEvents = 'none';

        board.position(pvState.startFen);
        updatePvUI();
    }

    function stopPvReview() {
        pvState.active = false;
        const box = document.getElementById('coachBox');
        box.classList.remove('pv-active');
        document.getElementById('board').classList.remove('board-pv-highlight');
        document.getElementById('pvModeBadge').classList.add('hidden');
        document.getElementById('mainNavButtons').style.opacity = '1';
        document.getElementById('mainNavButtons').style.pointerEvents = 'auto';
        updateUI();
    }

    function nextPvMove() {
        if (!pvState.active) return;
        if (pvState.currentIndex < pvState.moves.length - 1) {
            pvState.currentIndex++;
            pvState.tempGame.move(pvState.moves[pvState.currentIndex]);
            board.position(pvState.tempGame.fen());
            updatePvUI();
        }
    }

    function prevPvMove() {
        if (!pvState.active) return;
        if (pvState.currentIndex >= 0) {
            pvState.tempGame.undo();
            pvState.currentIndex--;
            board.position(pvState.tempGame.fen());
            updatePvUI();
        }
    }

    function updatePvUI() {
        const indicator = document.getElementById('pvMoveIndicator');
        const commentText = document.getElementById('pvCommentText');
        
        if (pvState.currentIndex === -1) {
            indicator.innerText = "Start";
            commentText.innerHTML = "<b>Position before mistake.</b><br>See what the engine recommends.";
        } else {
            const moveObj = pvState.moves[pvState.currentIndex];
            indicator.innerText = `Move ${pvState.currentIndex + 1}`;
            let comment = pvState.comments[pvState.currentIndex] || "Natural developing move.";
            commentText.innerHTML = `<b>${moveObj.san}:</b> ${comment}`;
        }
    }

    // --- 9. CORE ANALYSIS PIPELINE ---
    function cancelAnalysis() {
        isAnalyzing = false;
        document.getElementById('analysisOverlay').classList.add('hidden');
        document.getElementById('analyzeBtn').disabled = false;
    }

    function uciToSan(fen, pvString) {
        if (!pvString) return "";
        let moveCount = 1; // Simplified logic
        const temp = new Chess(fen);
        const moves = pvString.split(' ');
        let sanStr = "";
        
        for (let i = 0; i < moves.length; i++) {
            const m = moves[i];
            const from = m.substring(0, 2);
            const to = m.substring(2, 4);
            const promotion = m.length > 4 ? m.substring(4, 5) : undefined;
            
            const moveObj = temp.move({ from, to, promotion });
            if (moveObj) sanStr += moveObj.san + " ";
            else break;
        }
        return sanStr.trim();
    }

    // Lichess API Helpers
    async function fetchOpeningName(fen) {
        try {
            // Use 'masters' database to get the canonical opening name
            const response = await fetch(`https://explorer.lichess.ovh/masters?fen=${fen}`);
            const data = await response.json();
            if (data.opening) return data.opening.name;
        } catch (e) { console.warn("Opening fetch failed", e); }
        return null;
    }

    async function startAnalysis() {
        const apiKey = localStorage.getItem('gemini_api_key');
        if (!apiKey) { alert("Please add your Gemini API Key in settings first."); openSettings(); return; }
        
        const focus = document.getElementById('analysisFocus').value; 

        isAnalyzing = true;
        const overlay = document.getElementById('analysisOverlay');
        overlay.classList.remove('hidden');
        document.getElementById('analyzeBtn').disabled = true;
        document.getElementById('statusTitle').innerText = "Analyzing Depth & Tactics...";
        document.getElementById('geminiStatus').classList.add('hidden');
        document.getElementById('progressBar').style.width = "0%";

        const tempGame = new Chess();
        analysisData = [];

        try {
            // 1. ENGINE PASS
            for (let i = 0; i < gameHistory.length; i++) {
                if (!isAnalyzing) return; 

                const move = gameHistory[i];
                const pct = Math.round(((i + 1) / gameHistory.length) * 100);
                document.getElementById('progressBar').style.width = pct + "%";
                document.getElementById('progressText').innerText = `Stockfish: Move ${i+1}/${gameHistory.length}`;

                const fenBefore = tempGame.fen();
                
                // Fetch Opening Name for the first 10 moves
                let openingName = null;
                if (i < 10) openingName = await fetchOpeningName(fenBefore);

                const preMoveResult = await runStockfish(fenBefore);
                
                let bestMoveSan = preMoveResult.bestMove;
                let bestLineSan = "";
                
                if(preMoveResult.bestMove && preMoveResult.bestMove !== '-') {
                    const from = preMoveResult.bestMove.substring(0,2);
                    const to = preMoveResult.bestMove.substring(2,4);
                    const promotion = preMoveResult.bestMove.length > 4 ? preMoveResult.bestMove.substring(4,5) : undefined;
                    
                    const checkGame = new Chess(fenBefore);
                    const moveObj = checkGame.move({ from, to, promotion });
                    if(moveObj) bestMoveSan = moveObj.san;
                    
                    if (preMoveResult.pv) bestLineSan = uciToSan(fenBefore, preMoveResult.pv);
                }

                let currentEvalBefore = parseEval(preMoveResult.eval);
                tempGame.move(move.san);
                
                const postMoveResult = await runStockfish(tempGame.fen());
                let currentEvalAfter = parseEval(postMoveResult.eval);
                
                let delta = (move.color === 'w') ? (currentEvalAfter - currentEvalBefore) : (currentEvalBefore - currentEvalAfter);
                
                // Classification Logic
                let classification = "Neutral";
                if (i < 10 && openingName && Math.abs(delta) > -0.5) classification = "Book";
                else if (delta > 0.2) classification = "Best"; 
                else if (delta > -0.3) classification = "Good";
                else if (delta > -0.9) classification = "Inaccuracy"; 
                else if (delta > -2.0) classification = "Mistake"; 
                else if (delta > -4.0) classification = "Miss"; 
                else classification = "Blunder"; 

                if (move.san === bestMoveSan) classification = "Best";

                // Collect Data
                analysisData.push({
                    eval: currentEvalAfter.toFixed(2), 
                    wdl: preMoveResult.wdl, // "Win: 60%, Draw 30%, Loss 10%"
                    bestMoveSan: bestMoveSan,
                    pv: preMoveResult.pv, 
                    pvSan: bestLineSan, 
                    san: move.san,
                    color: move.color,
                    classification: classification,
                    fenBefore: fenBefore,
                    opening: openingName,
                    control: calculateBoardControl(fenBefore) // Calculate Board Control
                });
            }

            // 2. GEMINI PASS
            if (!isAnalyzing) return;
            
            document.getElementById('statusTitle').innerText = "Asking Coach...";
            document.getElementById('geminiStatus').classList.remove('hidden');
            document.getElementById('progressText').innerText = "AI is interpreting strategy...";
            document.getElementById('progressBar').className = "h-full bg-purple-500 transition-all duration-300 animate-pulse";
            
            await getGeminiCommentary(apiKey, focus);

        } catch (err) {
            console.error("Analysis failed:", err);
            alert("Error: " + err.message);
        } finally {
            overlay.classList.add('hidden');
            document.getElementById('analyzeBtn').disabled = false;
            isAnalyzing = false;
            
            if (analysisData.length > 0) {
               if(currentMoveIndex === -1) nextMove(); 
               else updateUI();
            }
        }
    }

    function parseEval(evalStr) {
        if (typeof evalStr === 'string' && evalStr.startsWith('M')) {
            return parseFloat(evalStr.replace('M', '')) > 0 ? 100 : -100; 
        }
        return parseFloat(evalStr);
    }

    function runStockfish(fen) {
        return new Promise(resolve => {
            if (!stockfish) initStockfish();

            const timeoutId = setTimeout(() => {
                resolve({ eval: "0.00", bestMove: "-", pv: "", wdl: "50-50" }); 
            }, 4000); // Slightly longer for WDL

            stockfish.postMessage('stop');
            stockfish.postMessage('position fen ' + fen);
            stockfish.postMessage('go depth 14'); 

            let best = "-";
            let evalScore = "0.00";
            let pvLine = "";
            let wdlStats = "";

            const listener = (e) => {
                const line = e.data;
                
                // Parse WDL (Win Draw Loss) if available
                // Format varies, often: "wdl 500 300 200" (per mill)
                if (line.includes(' wdl ')) {
                    const match = line.match(/wdl (\d+) (\d+) (\d+)/);
                    if (match) {
                        const w = parseInt(match[1]);
                        const d = parseInt(match[2]);
                        const l = parseInt(match[3]);
                        const total = w + d + l;
                        wdlStats = `Win: ${Math.round(w/total*100)}%`;
                    }
                }

                if (line.includes(' pv ')) {
                    const parts = line.split(' pv ');
                    if(parts[1]) pvLine = parts[1];
                }

                if (line.includes('cp ')) {
                    const match = line.match(/cp (-?\d+)/);
                    if(match) {
                        let score = parseInt(match[1]) / 100;
                        const side = fen.split(' ')[1];
                        if (side === 'b') score = -score;
                        evalScore = score.toFixed(2);
                    }
                }
                if (line.includes('mate ')) {
                    const match = line.match(/mate (-?\d+)/);
                    if(match) {
                        let mateIn = parseInt(match[1]);
                        const side = fen.split(' ')[1];
                        if (side === 'b') mateIn = -mateIn;
                        evalScore = "M" + mateIn;
                    }
                }
                if (line.startsWith('bestmove')) {
                    clearTimeout(timeoutId); 
                    best = line.split(' ')[1]; 
                    stockfish.removeEventListener('message', listener);
                    resolve({ eval: evalScore, bestMove: best, pv: pvLine, wdl: wdlStats }); 
                }
            };
            stockfish.addEventListener('message', listener);
        });
    }

    async function getGeminiCommentary(apiKey, focus) {
        let gameLog = "";
        
        // Construct the "Super Prompt" data
        analysisData.forEach((d, i) => {
            const isRelevant = focus === 'both' || focus === d.color;
            if(isRelevant) {
                // Focus on significant moves
                if(["Mistake", "Blunder", "Miss", "Best"].includes(d.classification) || i % 4 === 0) {
                    let context = `\n   FEN: ${d.fenBefore}`;
                    if(d.opening) context += `\n   Opening: ${d.opening}`;
                    if(d.wdl) context += `\n   WinProb: ${d.wdl}`;
                    context += `\n   Best Line (SAN): ${d.pvSan}`;
                    
                    gameLog += `Move ${i+1} (${d.color}): ${d.san} (Eval: ${d.eval}, Class: ${d.classification}, Better: ${d.bestMoveSan})${context}\n`;
                }
            }
        });

        if(!gameLog) gameLog = "Game was very balanced.";
        
        let focusInstruction = "Analyze both sides.";
        if(focus === 'w') focusInstruction = "Focus on White's plans.";
        if(focus === 'b') focusInstruction = "Focus on Black's plans.";

        const prompt = `
        You are a Grandmaster Chess Coach. ${focusInstruction}

        **TASK:**
        1. Identify the **Opening Name** and general plan (e.g. "Control d4").
        2. Analyze key turning points using the Win Probability (WinProb) data.
        3. For "Mistakes", explain *why* the Best Line is better (tactically or strategically).
        
        **JSON OUTPUT FORMAT:**
        {
            "12": {
                "analysis": "You missed a tactic here. The win probability dropped by 20%.",
                "pv_explanation": [
                    "Nf6 checks the King.",
                    "Kxe7 is forced.",
                    "Qxd8 wins material."
                ]
            }
        }
        
        **Game Data:**
        ${gameLog}
        `;

        try {
            const response = await fetch(GEMINI_API_URL + `?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { response_mime_type: "application/json" }
                })
            });

            const data = await response.json();
            if(data.error) throw new Error(data.error.message);
            
            const jsonText = data.candidates[0].content.parts[0].text;
            geminiComments = JSON.parse(jsonText);
            
        } catch (e) {
            console.error("Gemini Error:", e);
            geminiComments = { 1: { analysis: "Analysis failed. Please check API Key." } };
        }
    }

    // --- 10. CHAT ---
    async function sendChatMessage() {
        const input = document.getElementById('chatInput');
        const text = input.value;
        const apiKey = localStorage.getItem('gemini_api_key');
        
        if(!apiKey) { alert("Please save API key first"); return; }
        if(!text) return;

        const chatHistory = document.getElementById('chatHistory');
        chatHistory.innerHTML += `<div class="bg-indigo-50 p-2 rounded mb-2 text-right"><b>You:</b> ${text}</div>`;
        input.value = "";
        chatHistory.scrollTop = chatHistory.scrollHeight;

        const data = analysisData[currentMoveIndex] || {};
        
        const prompt = `
        Context: 
        PGN: ${game.pgn()}
        Current FEN: ${game.fen()}
        Opening: ${data.opening || "Unknown"}
        Stockfish Eval: ${data.eval}
        Best Move: ${data.bestMoveSan}
        
        User Question: ${text}
        
        Answer as a Coach. Keep it brief and helpful.
        `;

        try {
            const response = await fetch(GEMINI_API_URL + `?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });
            const resData = await response.json();
            const reply = resData.candidates[0].content.parts[0].text;
            
            chatHistory.innerHTML += `<div class="text-left mb-2 text-gray-700"><b>Coach:</b> ${marked.parse(reply)}</div>`;
            chatHistory.scrollTop = chatHistory.scrollHeight;

        } catch (e) {
            chatHistory.innerHTML += `<div class="text-red-500 text-xs">Error contacting Coach. Check API Key.</div>`;
        }
    }

    function handleChatEnter(e) { if(e.key === 'Enter') sendChatMessage(); }

    // --- SETTINGS ---
    function saveSettings() {
        const key = document.getElementById('apiKeyInput').value.trim();
        if(!key) { alert("Please enter a key."); return; }
        localStorage.setItem('gemini_api_key', key);
        document.getElementById('settingsModal').classList.add('hidden');
    }

    function loadSettings() {
        const key = localStorage.getItem('gemini_api_key');
        if(key) document.getElementById('apiKeyInput').value = key;
    }
    
    function openSettings() {
        loadSettings();
        document.getElementById('settingsModal').classList.remove('hidden');
    }
</script>
